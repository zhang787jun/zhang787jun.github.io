<!DOCTYPE HTML>
<html>

<head>
    <link rel="Stylesheet" type="text/css" href="/Wiki/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/Wiki/static/css/tango.css">
    <link rel="shortcut icon" href="/Wiki/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/Wiki/favicon.ico" type="image/x-icon">
    <title>数据结构及算法思想的实现 - Jun's personal knowledge wiki</title>
    <meta name="keywords" content="Technology, MachineLearning, DataMining, Wiki" />
    <meta name="description" content="A wiki website" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
            }
        });
    </script>
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
        </script>
</head>

<body>

    <div id="container">
        
<div id="header">
  <div id="post-nav"><a href="/Wiki/">Home</a>&nbsp;»&nbsp;<a href="/Wiki/#Basic_CS">Basic_CS</a>&nbsp;»&nbsp;<a href="/Wiki/#-Algorithm">Algorithm</a>&nbsp;»&nbsp;数据结构及算法思想的实现</div>
</div>
<div class="clearfix"></div>
<div id="title">数据结构及算法思想的实现</div>
<div id="content">
  <h1 id="_1">数据结构及算法思想的实现</h1>
<div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#_1">数据结构及算法思想的实现</a><ul>
<li><a href="#0">0. 算法评价</a><ul>
<li><a href="#01">0.1. 时间消耗</a></li>
<li><a href="#02">0.2. 空间消耗</a></li>
<li><a href="#03">0.3. 时间复杂度/空间复杂度</a><ul>
<li><a href="#031">0.3.1 工具</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1">1. 基础数据结构</a><ul>
<li><a href="#11">1.1 链表</a><ul>
<li><a href="#111">1.1.1 基本链表</a></li>
<li><a href="#112">1.1.2. 双向链表</a></li>
<li><a href="#113">1.1.3. 循环链表</a></li>
</ul>
</li>
<li><a href="#12">1.2 数组</a></li>
<li><a href="#13">1.3 栈</a></li>
<li><a href="#14">1.4 队列</a></li>
<li><a href="#15">1.5 哈希表</a><ul>
<li><a href="#1_1">1. 哈希（散列/摘要）函数</a></li>
<li><a href="#2">2. 冲突处理</a><ul>
<li><a href="#21">2.1 开放寻址法</a></li>
<li><a href="#22">2.2 链地址法</a></li>
<li><a href="#23">2.3 建立一个公共溢出区</a></li>
</ul>
</li>
<li><a href="#3">3. 实现</a></li>
</ul>
</li>
<li><a href="#17">1.7 树</a><ul>
<li><a href="#171">1.7.1 二叉树</a><ul>
<li><a href="#1711">1.7.1.1 二叉查找树</a></li>
<li><a href="#1712">1.7.1.2 堆</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#2_1">2.基础算法思想</a><ul>
<li><a href="#1_2">1. 枚举/遍历</a><ul>
<li><a href="#11_1">1.1 枚举的基本思想</a></li>
<li><a href="#12_1">1.2 枚举过程</a></li>
<li><a href="#13_1">1.3 枚举中的三个关键问题</a></li>
<li><a href="#_2">双指针枚举</a></li>
</ul>
</li>
<li><a href="#2_2">2. 递归</a><ul>
<li><a href="#21_1">2.1 递归的基本思想</a></li>
<li><a href="#22_1">2.2  递归与枚举</a></li>
<li><a href="#23_1">2.3 三个要点</a></li>
<li><a href="#24-">2.4 关键--递推公式\递归中止条件</a></li>
</ul>
</li>
<li><a href="#3_1">3. 动态规划</a><ul>
<li><a href="#31">3.1 动态规划的基本思想</a></li>
<li><a href="#32">3.2 动规解题的一般思路：</a></li>
</ul>
</li>
<li><a href="#4">4. 深度优先搜索</a><ul>
<li><a href="#41-dfs">4.1 dfs</a></li>
<li><a href="#42">4.2  剪枝</a><ul>
<li><a href="#421">4.2.1 剪枝的关键</a></li>
<li><a href="#422">4.2.2 剪枝的原则</a></li>
<li><a href="#423">4.2.3 常用的剪枝</a><ul>
<li><a href="#4231">4.2.3.1. 可行性剪枝</a></li>
<li><a href="#4232">4.2.3.2. 最优性剪枝</a></li>
<li><a href="#4233">4.2.3.3. 记忆化搜索</a></li>
<li><a href="#4234">4.2.3.4. 搜索顺序剪枝</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#5">5. 广度优先搜索</a><ul>
<li><a href="#51">5.1 核心思想</a></li>
</ul>
</li>
<li><a href="#6">6. 二分</a></li>
<li><a href="#7">7. 贪心</a></li>
</ul>
</li>
<li><a href="#3_2">3.基于问题的划分</a><ul>
<li><a href="#31_1">3.1 排序</a><ul>
<li><a href="#_3">希尔排序</a></li>
<li><a href="#312">3.1.2 选择排序</a><ul>
<li><a href="#_4">简单选择排序</a></li>
<li><a href="#_5">堆排序</a></li>
</ul>
</li>
<li><a href="#313">3.1.3. 交换排序</a><ul>
<li><a href="#_6">冒泡排序</a></li>
<li><a href="#_7">快速排序</a></li>
</ul>
</li>
<li><a href="#314">3.1.4 归并排序</a></li>
</ul>
</li>
<li><a href="#32_1">3.2 查找</a><ul>
<li><a href="#321">3.2.1. 二分查找</a></li>
<li><a href="#322">3.2.2. 顺序查找</a></li>
<li><a href="#323">3.2.3 哈希表查找</a></li>
<li><a href="#324">3.2.4 二叉搜索树查找</a></li>
</ul>
</li>
<li><a href="#33">3.3 图的搜索</a><ul>
<li><a href="#331">3.3.1 树的遍历</a><ul>
<li><a href="#3311">3.3.1.1 前序</a></li>
<li><a href="#3312">3.3.1.2 中序</a></li>
<li><a href="#3313">3.3.1.3 后序</a></li>
</ul>
</li>
<li><a href="#332">3.3.2 广度优先搜索</a></li>
<li><a href="#333">3.3.3 深度优先搜索</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#_8">参考资料</a></li>
</ul>
</div>
<h2 id="0">0. 算法评价</h2>
<h3 id="01">0.1. 时间消耗</h3>
<div class="hlcode"><pre><span class="n">vim</span>  <span class="n">python_file</span><span class="p">.</span><span class="n">py</span>
<span class="o">---</span>
<span class="n">print</span> <span class="p">(</span><span class="s">&quot;hello world&quot;</span><span class="p">)</span>
<span class="o">---</span>
<span class="n">time</span> <span class="n">python</span> <span class="n">python_file</span><span class="p">.</span><span class="n">py</span>
<span class="o">&gt;&gt;&gt;</span> 
    <span class="n">real</span>    <span class="mi">0</span><span class="n">m0</span><span class="mf">.146</span><span class="n">s</span>
    <span class="n">user</span>    <span class="mi">0</span><span class="n">m0</span><span class="mf">.047</span><span class="n">s</span>
    <span class="n">sys</span>     <span class="mi">0</span><span class="n">m0</span><span class="mf">.063</span><span class="n">s</span>
</pre></div>


<h3 id="02">0.2. 空间消耗</h3>
<div class="hlcode"><pre><span class="n">import</span> <span class="n">sys</span>
<span class="n">sys</span><span class="p">.</span><span class="n">getsizeof</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">123</span> <span class="err">#</span><span class="n">betye</span>
</pre></div>


<p>VSS- Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）<br />
RSS- Resident Set Size 实际使用物理内存（包含共享库占用的内存）<br />
PSS- Proportional Set Size 实际使用的物理内存（比例分配共享库占用的内存）<br />
USS- Unique Set Size 进程独自占用的物理内存（不包含共享库占用的内存）</p>
<p>一般来说内存占用大小有如下规律：VSS &gt;= RSS &gt;= PSS &gt;= USS</p>
<h3 id="03">0.3. 时间复杂度/空间复杂度</h3>
<blockquote>
<p>大O法（Order）：$O(n)$</p>
</blockquote>
<ol>
<li>
<p>空间复杂度(Space Complexity)<br />
执行这个算法所需要的内存空间  $S(n)=···=O(n)$</p>
</li>
<li>
<p>时间复杂度（Time Complexity）<br />
时间复杂度是指执行算法所需要的计算工作量 $T(n)=···=O(n)$</p>
</li>
</ol>
<h4 id="031">0.3.1 工具</h4>
<h2 id="1">1. 基础数据结构</h2>
<h3 id="11">1.1 链表</h3>
<p>非连续内存存储<br />
类型：</p>
<h4 id="111">1.1.1 基本链表</h4>
<div class="hlcode"><pre><span class="c"># python</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">=</span><span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span><span class="o">=</span><span class="bp">None</span>
    <span class="c"># 获得数据</span>
    <span class="k">def</span> <span class="nf">getData</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
    <span class="c"># 获得下一个节点的引用</span>
    <span class="k">def</span> <span class="nf">getNext</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">next</span>
    <span class="c"># 修改数据</span>
    <span class="k">def</span> <span class="nf">setData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newdata</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">newdata</span>
    <span class="c"># 修改下一节点的引用</span>
    <span class="k">def</span> <span class="nf">setNext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newnext</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">newnext</span>
</pre></div>


<div class="hlcode"><pre><span class="k">struct</span> <span class="n">ListNode</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<h4 id="112">1.1.2. 双向链表</h4>
<h4 id="113">1.1.3. 循环链表</h4>
<h3 id="12">1.2 数组</h3>
<p>连续内存存储</p>
<ol>
<li>python</li>
</ol>
<div class="hlcode"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="err">···，</span><span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">shape</span><span class="o">=</span><span class="p">[])</span>
</pre></div>


<p>

| 类型        | 说明                         |
| :---------- | :--------------------------- |
| numpy array | 内存中一个连续块             |
| list        | 每个元素其实是一个地址的引用 |

一个numpy array需要确定变量类型(int/float32)和大小，然后在 是内存中申请一个确定大小的连续块。

list完全不同，它的每个元素其实是一个地址的引用，这个地址又指向了另一个元素，这些元素的在内存里不一定是连续的。所以list其实是只能塞进地址的“数组”，而且由于地址不用连续，每当我想加入新元素，我只用把这个元素的地址添加进list
</p>

<div class="hlcode"><pre><span class="n">list_1</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;abc&quot;</span><span class="p">,</span><span class="s">&quot;defffff&quot;</span><span class="p">,</span><span class="s">&quot;ghiiiiiiiiiii&quot;</span><span class="p">]</span>
<span class="n">list_2</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;abc&quot;</span><span class="p">,</span><span class="s">&quot;defffff&quot;</span><span class="p">]</span>
<span class="n">list_3</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;abc&quot;</span><span class="p">]</span>
<span class="n">array_1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">list_1</span><span class="p">)</span>
<span class="n">array_2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">list_2</span><span class="p">)</span>
<span class="n">array_3</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">list_3</span><span class="p">)</span>

<span class="k">print</span> <span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="n">list_1</span><span class="p">)</span><span class="o">-</span><span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="n">list_2</span><span class="p">))</span> <span class="c">#8 </span>
<span class="k">print</span> <span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="n">list_2</span><span class="p">)</span><span class="o">-</span><span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="n">list_3</span><span class="p">))</span> <span class="c">#8</span>
<span class="k">print</span> <span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="n">list_3</span><span class="p">))</span> <span class="c">#72</span>

<span class="k">print</span> <span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="n">array_1</span><span class="p">)</span><span class="o">-</span><span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="n">array_2</span><span class="p">))</span> <span class="c">#100</span>
<span class="k">print</span> <span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="n">array_2</span><span class="p">)</span><span class="o">-</span><span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="n">array_3</span><span class="p">))</span> <span class="c"># 44</span>
<span class="k">print</span> <span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="n">array_3</span><span class="p">))</span> <span class="c"># 108</span>

<span class="k">print</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="s">&quot;abc&quot;</span><span class="p">))</span> <span class="c">#60</span>
<span class="k">print</span> <span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="s">&quot;defffff&quot;</span><span class="p">))</span> <span class="c">#72</span>
<span class="k">print</span> <span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="s">&quot;ghiiiiiiiiiii&quot;</span><span class="p">))</span> <span class="c">#90 </span>
</pre></div>


<ol>
<li>c++</li>
</ol>
<div class="hlcode"><pre><span class="c1">// 1维数组</span>

<span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span> 　　<span class="c1">//定义了数组array，并未对数组进行初始化</span>
<span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="err">，</span><span class="mi">2</span><span class="p">}</span><span class="err">；</span>　　<span class="c1">//定义并初始化了数组array</span>

<span class="kt">int</span><span class="o">*</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>  
<span class="k">delete</span> <span class="p">[]</span><span class="n">array</span><span class="p">;</span>　　<span class="c1">//分配了长度为100的数组array </span>

<span class="kt">int</span><span class="o">*</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">100</span><span class="p">](</span><span class="mi">1</span><span class="err">，</span><span class="mi">2</span><span class="p">);</span> 　
<span class="k">delete</span> <span class="p">[]</span><span class="n">array</span><span class="p">;</span>　<span class="c1">//为长度为100的数组array初始化前两个元素</span>

<span class="c1">//2 维数组</span>

<span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="mi">10</span><span class="p">];</span>　　<span class="c1">//定义了数组，并未初始化</span>
<span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span> <span class="p">,</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span> <span class="p">};</span>　　<span class="c1">//数组初始化了array[0][0,1]及array[1][0,1]</span>

<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">array</span><span class="p">)[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">];</span>
<span class="k">delete</span> <span class="p">[]</span><span class="n">array</span><span class="p">;</span>

<span class="kt">int</span><span class="o">**</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">*</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>　
<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>  
<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">delete</span> <span class="p">[]</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> 
<span class="k">delete</span> <span class="p">[]</span><span class="n">array</span><span class="p">;</span>    <span class="c1">//多次析构</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">];</span>  
<span class="k">delete</span> <span class="p">[]</span><span class="n">array</span><span class="p">;</span>      <span class="c1">//数组按行存储</span>

<span class="c1">//多维数组</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">];</span>    <span class="c1">//只有第一维可以是变量，其他维数必须是常量，否则会报错</span>
<span class="k">delete</span> <span class="p">[]</span><span class="n">array</span><span class="p">;</span>       <span class="c1">//必须进行内存释放，否则内存将泄漏</span>
</pre></div>


<h3 id="13">1.3 栈</h3>
<p>LIFO队列,Last in First Out,后进先出</p>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Stack</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">def</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">==</span><span class="p">[]</span>
    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">item</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isEmpty</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">,</span><span class="s">&#39;pop from empty stack&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">)</span>

<span class="c"># 内置</span>
<span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">LifoQueue</span> <span class="c">#LIFO队列,Last in First Out,后进先出</span>
<span class="n">lifoQueue</span> <span class="o">=</span> <span class="n">LifoQueue</span><span class="p">()</span>
<span class="n">lifoQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">lifoQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">lifoQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;LIFO队列&#39;</span><span class="p">,</span><span class="n">lifoQueue</span><span class="o">.</span><span class="n">queue</span><span class="p">)</span>
<span class="n">lifoQueue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="c">#返回并删除队列尾部元素</span>
<span class="n">lifoQueue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">lifoQueue</span><span class="o">.</span><span class="n">queue</span><span class="p">)</span>
</pre></div>


<h3 id="14">1.4 队列</h3>
<p>Last in Last Out,后进后出</p>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Queue</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">def</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">==</span><span class="p">[]</span>
    <span class="k">def</span> <span class="nf">enqueue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">dequeue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">:</span>
            <span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">a</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">,</span><span class="s">&#39;queue is empty&#39;</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">)</span>

<span class="c"># 内置</span>
<span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">Queue</span> <span class="c">#LILO队列 Last in Last Out,后进后出</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span> <span class="c">#创建队列对象</span>
<span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>    <span class="c">#在队列尾部插入元素</span>
<span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;LILO队列&#39;</span><span class="p">,</span><span class="n">q</span><span class="o">.</span><span class="n">queue</span><span class="p">)</span>  <span class="c">#查看队列中的所有元素</span>
<span class="k">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>  <span class="c">#返回并删除队列头部元素</span>
<span class="k">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">queue</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">PriorityQueue</span> <span class="c">#优先队列</span>
<span class="n">priorityQueue</span> <span class="o">=</span> <span class="n">PriorityQueue</span><span class="p">()</span> <span class="c">#创建优先队列对象</span>
<span class="n">priorityQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>    <span class="c">#插入元素</span>
<span class="n">priorityQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="mi">78</span><span class="p">)</span>   <span class="c">#插入元素</span>
<span class="n">priorityQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>  <span class="c">#插入元素</span>
<span class="k">print</span><span class="p">(</span><span class="n">priorityQueue</span><span class="o">.</span><span class="n">queue</span><span class="p">)</span>  <span class="c">#查看优先级队列中的所有元素</span>
<span class="n">priorityQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>    <span class="c">#插入元素</span>
<span class="n">priorityQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>    <span class="c">#插入元素</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;优先级队列:&#39;</span><span class="p">,</span><span class="n">priorityQueue</span><span class="o">.</span><span class="n">queue</span><span class="p">)</span>  <span class="c">#查看优先级队列中的所有元素</span>
<span class="n">priorityQueue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="c">#返回并删除优先级最低的元素</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;删除后剩余元素&#39;</span><span class="p">,</span><span class="n">priorityQueue</span><span class="o">.</span><span class="n">queue</span><span class="p">)</span>
<span class="n">priorityQueue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="c">#返回并删除优先级最低的元素</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;删除后剩余元素&#39;</span><span class="p">,</span><span class="n">priorityQueue</span><span class="o">.</span><span class="n">queue</span><span class="p">)</span>  <span class="c">#删除后剩余元素</span>
<span class="n">priorityQueue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="c">#返回并删除优先级最低的元素</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;删除后剩余元素&#39;</span><span class="p">,</span><span class="n">priorityQueue</span><span class="o">.</span><span class="n">queue</span><span class="p">)</span>  <span class="c">#删除后剩余元素</span>
<span class="n">priorityQueue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="c">#返回并删除优先级最低的元素</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;删除后剩余元素&#39;</span><span class="p">,</span><span class="n">priorityQueue</span><span class="o">.</span><span class="n">queue</span><span class="p">)</span>  <span class="c">#删除后剩余元素</span>
<span class="n">priorityQueue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="c">#返回并删除优先级最低的元素</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;全部被删除后:&#39;</span><span class="p">,</span><span class="n">priorityQueue</span><span class="o">.</span><span class="n">queue</span><span class="p">)</span>  <span class="c">#查看优先级队列中的所有元素</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>   <span class="c">#双端队列</span>
<span class="n">dequeQueue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="s">&#39;Eric&#39;</span><span class="p">,</span><span class="s">&#39;John&#39;</span><span class="p">,</span><span class="s">&#39;Smith&#39;</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="n">dequeQueue</span><span class="p">)</span>
<span class="n">dequeQueue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;Tom&#39;</span><span class="p">)</span>    <span class="c">#在右侧插入新元素</span>
<span class="n">dequeQueue</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="s">&#39;Terry&#39;</span><span class="p">)</span>  <span class="c">#在左侧插入新元素</span>
<span class="k">print</span><span class="p">(</span><span class="n">dequeQueue</span><span class="p">)</span>
<span class="n">dequeQueue</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>    <span class="c">#循环右移2次</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;循环右移2次后的队列&#39;</span><span class="p">,</span><span class="n">dequeQueue</span><span class="p">)</span>
<span class="n">dequeQueue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>    <span class="c">#返回并删除队列最左端元素</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;删除最左端元素后的队列：&#39;</span><span class="p">,</span><span class="n">dequeQueue</span><span class="p">)</span>
<span class="n">dequeQueue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>    <span class="c">#返回并删除队列最右端元素</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;删除最右端元素后的队列：&#39;</span><span class="p">,</span><span class="n">dequeQueue</span><span class="p">)</span>
</pre></div>


<h3 id="15">1.5 哈希表</h3>
<p>哈希表，一种key-value形式的数据结构</p>
<p><strong>场景</strong>：<br />
    1. 数据量大了之后，线性插值某一value 资源消耗大</p>
<p>构建哈希表的关键在于运用<code>1.哈希函数及相应的数学运算</code> 和<code>2. 冲突管理机制</code>构建<code>哈希表地址</code><br />
<strong>关键点：</strong><br />
1. 哈希函数<br />
2. 冲突处理`</p>
<div class="hlcode"><pre>    <span class="n">address_in_table</span><span class="o">=</span><span class="n">hash</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="n">mod</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">address_in_table</span> <span class="err">相同</span><span class="o">:</span>
        <span class="err">依据冲突处理规则处理</span>
    <span class="k">return</span> <span class="n">address_in_table</span>
</pre></div>


<h4 id="1_1">1. 哈希（散列/摘要）函数</h4>
<p>功能：将给定数据转换成为固定长度的无规律数值<br />
特性:<br />
1. 函数输出的长度相同<br />
2. 相同输入数据的输出相同<br />
3. 不同数据输出大概率不同<br />
4. 不同输入的输出也有可能相同（概率低），若发生则成为<code>哈希冲突</code><br />
5. 不可逆，不可以通过输出反推出输入值<br />
6. 正向计算较为容易</p>
<table>
<thead>
<tr>
<th align="right">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">md4</td>
<td align="left">MD4(RFC 1320）是 MIT 的Ronald L. Rivest在 1990 年设计的，MD 是 Message Digest 的缩写。它适用在32位字长的处理器上用高速软件实现--它是基于 32位操作数的位操作来实现的。</td>
</tr>
<tr>
<td align="right">md5</td>
<td align="left">MD5(RFC 1321）是 Rivest 于1991年对MD4的改进版本。它对输入仍以512位分组，其输出是4个32位字的级联，与 MD4 相同。MD5比MD4来得复杂，并且速度较之要慢一点，但更安全，在抗分析和抗差分方面表现更好</td>
</tr>
<tr>
<td align="right">sha1</td>
<td align="left">SHA1是由NIST NSA设计为同DSA一起使用的，它对长度小于2^64位的输入，产生长度为160bit的散列值，因此抗穷举（brute-force）性更好。SHA-1 设计时基于和MD4相同原理，并且模仿了该算法。</td>
</tr>
<tr>
<td align="right">sha2</td>
<td align="left">较常使用</td>
</tr>
</tbody>
</table>
<div class="hlcode"><pre><span class="kn">import</span> <span class="nn">hashlib</span>

<span class="n">md5</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">()</span>
<span class="n">md5</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="s">&#39;how to use md5 in python hashlib?&#39;</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">md5</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">())</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">d26a53750bc40b38b65a520292f69306</span>
</pre></div>


<p>哈希表地址的表示方法<br />
 (1) 除法散列法</p>
<p>哈希表的大小为m行,通过取哈希值hash_num除以m的余数，将关键字映射到m个槽中去，即</p>
<p><code>hash_num=hash(key)</code><br />
$$address_in_table= mod(hash_num,m)$$</p>
<p>其中m的取值很重要，这个函数得出的散列地址值不会超过m，同时可以选作p的值常常是与2的整数幂不太接近的质数。当存放位置m较大时，p不宜过小。</p>
<p>(2)乘法散列法</p>
<p>$$h(hash_ num)=[p<em>(hash_num</em>A-(int)hash_num*A)]$$</p>
<p>用hash_num乘以常数A,并且抽出kA的小数部分，然后用m乘以这个值，再取底floor.</p>
<p>其中0&lt;A&lt;1,一般取，$(\sqrt5-1)/2$，m没有太多限制，一般取2的整数次幂</p>
<p>(3)全域散列</p>
<h4 id="2">2. 冲突处理</h4>
<p>当数据量大了之后，哈希地址表就不是唯一的，就存在冲突。</p>
<h5 id="21">2.1 开放寻址法</h5>
<h5 id="22">2.2 链地址法</h5>
<p>把散列到同一个槽中的所有元素都放在一个链表中。相对于开放地址法，可能会增加存储空间。</p>
<h5 id="23">2.3 建立一个公共溢出区</h5>
<p>若发生冲突，把key存入公共溢出区。</p>
<h4 id="3">3. 实现</h4>
<p>在Python中，dict的底层是依靠哈希表(Hash Table)进行实现的，使用开放地址法解决冲突。所以其查找的时间复杂度会是O(1)</p>
<div class="hlcode"><pre><span class="c"># python dict </span>
<span class="nb">dict</span><span class="o">=</span><span class="p">{</span><span class="n">key</span><span class="p">:</span><span class="n">value</span><span class="p">}</span>
</pre></div>


<div class="hlcode"><pre><span class="cp">#include &lt;iostream&gt; </span>
<span class="cp">#include &lt;vector&gt; </span>
<span class="cp">#include &lt;unordered_map&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span> 

<span class="k">class</span> <span class="nc">Myclass</span> <span class="p">{</span> 
    <span class="k">public</span><span class="o">:</span> <span class="kt">int</span> <span class="n">first</span><span class="p">;</span> 
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">second</span><span class="p">;</span> <span class="c1">// 重载等号，判断两个Myclass类型的变量是否相等 </span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span> <span class="p">(</span><span class="k">const</span> <span class="n">Myclass</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> 
        <span class="k">return</span> <span class="n">first</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">first</span> <span class="o">&amp;&amp;</span> <span class="n">second</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">second</span><span class="p">;</span> <span class="p">}</span> <span class="p">};</span> <span class="c1">// 实现Myclass类的hash函数 </span>

    <span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span> 
        <span class="k">template</span> <span class="o">&lt;&gt;</span> <span class="k">struct</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">Myclass</span><span class="o">&gt;</span> <span class="p">{</span> 
            <span class="kt">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Myclass</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">)</span> <span class="k">const</span> 
            <span class="p">{</span>   <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">k</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">x</span> <span class="o">:</span> <span class="n">k</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span> 
                    <span class="n">h</span> <span class="o">^=</span> <span class="n">x</span><span class="p">;</span>
                    <span class="p">}</span> 
                <span class="k">return</span> <span class="n">h</span><span class="p">;</span>
                <span class="p">}</span> 
        <span class="p">};</span> 
    <span class="p">}</span> 

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span> 
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Myclass</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">S</span><span class="p">;</span> 
    <span class="n">Myclass</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span> <span class="p">};</span> 
    <span class="n">Myclass</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span> <span class="p">};</span>
    <span class="n">S</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.5</span><span class="p">;</span> 
    <span class="n">S</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.123</span><span class="p">;</span> 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">S</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span> <span class="o">&lt;&lt;</span> <span class="n">S</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
 <span class="p">}</span>
</pre></div>


<div class="hlcode"><pre><span class="k">class</span> <span class="nc">LinearMap</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c"># 往表中添加元素    </span>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>  
        <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">))</span>

    <span class="c"># 线性方式查找元素</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span> 
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">:</span>      
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>      <span class="c"># 键存在，返回值，否则抛出异常</span>
                <span class="k">return</span> <span class="n">value</span>
        <span class="k">raise</span> <span class="ne">KeyError</span>
</pre></div>


<h3 id="17">1.7 树</h3>
<h4 id="171">1.7.1 二叉树</h4>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">BinaryTree</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">rootObj</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">rootObj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">insertLeft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">newNode</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">leftChild</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span><span class="n">newNode</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span><span class="n">newNode</span><span class="p">)</span>
            <span class="n">t</span><span class="o">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leftChild</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="n">t</span>

    <span class="k">def</span> <span class="nf">insertRight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">newNode</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rightChild</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span><span class="n">newNode</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span><span class="n">newNode</span><span class="p">)</span>
            <span class="n">t</span><span class="o">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rightChild</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="n">t</span>
    <span class="k">def</span> <span class="nf">getRightChild</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rightChild</span>

    <span class="k">def</span> <span class="nf">getLeftChild</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">leftChild</span>

    <span class="k">def</span> <span class="nf">setRootVal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">obj</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">getRootVal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span>
</pre></div>


<h5 id="1711">1.7.1.1 二叉查找树</h5>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">BinarySearchTree</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="o">=</span><span class="n">key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">leftChild</span><span class="o">=</span><span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rightChild</span><span class="o">=</span><span class="bp">None</span>

    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">parent</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">parent</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">data</span> <span class="o">&gt;</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">leftChild</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">rightChild</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="c"># 插入</span>
    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">flag</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">:</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="n">BinarySearchTree</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span> <span class="o">&gt;</span> <span class="n">p</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="n">new_node</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="n">new_node</span>
</pre></div>


<h5 id="1712">1.7.1.2 堆</h5>
<p>堆(heap)又被为优先队列(priority queue)</p>
<div class="hlcode"><pre><span class="kn">import</span> <span class="nn">heapq</span> 
<span class="n">heap</span> <span class="o">=</span> <span class="p">[]</span>            <span class="c"># creates an empty heap</span>
<span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="c"># pushes a new item on the heap</span>
<span class="n">item</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span> <span class="c"># pops the smallest item from the heap</span>
<span class="n">item</span> <span class="o">=</span> <span class="n">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>       <span class="c"># smallest item on the heap without popping it</span>
<span class="n">heapify</span><span class="p">(</span><span class="n">list_x</span><span class="p">)</span>           <span class="c"># transforms list into a heap, in-place, in linear time</span>
<span class="n">item</span> <span class="o">=</span> <span class="n">heapreplace</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="c"># 返回最小值，同时将新item加入堆中，堆的大小不变</span>
</pre></div>


<h2 id="2_1">2.基础算法思想</h2>
<h3 id="1_2">1. 枚举/遍历</h3>
<h4 id="11_1">1.1 枚举的基本思想</h4>
<p>枚举是基于已有知识进行答案猜测的一种问题求解策略。</p>
<p>枚举从可能的集合中一一列举各元素， 对问题可能解集合的每一项，根据问题给定的检验条件判定哪些是成立的，使条件成立的即是问题的解。</p>
<h4 id="12_1">1.2 枚举过程</h4>
<ul>
<li>判断猜测的答案是否正确</li>
<li>进行新的猜测: 有两个关键因素要注意</li>
<li>猜测的结果必须是前面的猜测中没有出现过的. </li>
<li>猜测的过程中要及早排除错误的答案. </li>
</ul>
<h4 id="13_1">1.3 枚举中的三个关键问题</h4>
<ol>
<li>
<p>给出解空间</p>
<ul>
<li>给出解空间，建立简洁的数学模型 </li>
<li>模型中变量数尽可能少, 它们之间相互独立 </li>
</ul>
</li>
<li>
<p>减少搜索空间</p>
<ul>
<li>利用知识缩小模型中各变量的取值范围, 避免不必要的计算 </li>
<li>减少代码中循环体执行次数</li>
</ul>
</li>
<li>合适的搜索顺序<ul>
<li>搜索空间的遍历顺序要与模型中条件表达式一致 </li>
</ul>
</li>
</ol>
<div class="hlcode"><pre><span class="n">D</span><span class="o">=</span><span class="p">{}</span>
<span class="k">while</span> <span class="p">(</span><span class="err">没有找到正确答案</span><span class="p">)</span><span class="err">：</span>
    <span class="err">正确答案</span><span class="o">=</span><span class="n">Di</span><span class="o">?</span>
    <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
</pre></div>


<h4 id="_2">双指针枚举</h4>
<p>双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。<br />
双指针：<br />
1. 慢指针<br />
2. 快指针<br />
双指针可以从不同的方向向中间逼近也可以朝着同一个方向遍历</p>
<h3 id="2_2">2. 递归</h3>
<p>分治法就是把1个分为多个，递归法就是把多个归一的解决问题方法。<br />
递归问题是一种层次结构的分治策略--拆解成小问题--判断停止条件</p>
<h4 id="21_1">2.1 递归的基本思想</h4>
<p>递归 — 某个函数直接或间接的调用自身<br />
问题的求解过程</p>
<ul>
<li>划分成许多相同性质的子问题的求解</li>
<li>而小问题的求解过程可以很容易的求出</li>
</ul>
<p>这些子问题的解就构成里原问题的解</p>
<h4 id="22_1">2.2  递归与枚举</h4>
<p>枚举把一个问题划分成一组子问题，依次对这些子问题求解</p>
<ul>
<li>子问题之间是横向的，同类的关系</li>
</ul>
<p>把一个问题逐级分解成子问题</p>
<ul>
<li>子问题与原问题之间是纵向的, 同类的关系</li>
<li>语法形式上: 在一个函数的运行过程中, 调用这个函数自己</li>
<li>直接调用: 在<code>fun()</code>中直接执行<code>fun()</code></li>
<li>间接调用: 在<code>fun1()</code>中执行<code>fun2()</code>; 在<code>fun2()</code>中又执行<code>fun1()</code></li>
</ul>
<h4 id="23_1">2.3 三个要点</h4>
<ul>
<li>递归式</li>
<li>如何将原问题划分成子问题</li>
<li>递归出口</li>
<li>递归终止的条件, 即最小子问题的求解,可以允许多个出口</li>
<li>界函数</li>
<li>问题规模变化的函数, 它保证递归的规模向出口条件靠拢</li>
</ul>
<h4 id="24-">2.4 关键--递推公式\递归中止条件</h4>
<ul>
<li>找出递推公式</li>
<li>找到递归终止条件</li>
</ul>
<p>注意事项: 由于函数的局部变量是存在栈上的，如果有体积大的局部变量（比如数组）而递归层次可能很深的情况下，也许会导致栈溢出。可以考虑使用全局数组或动态分配数组。</p>
<div class="hlcode"><pre><span class="n">function</span> <span class="p">(</span><span class="n">n</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">function</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h3 id="3_1">3. 动态规划</h3>
<h4 id="31">3.1 动态规划的基本思想</h4>
<ul>
<li>避免重复计算 </li>
<li>存储</li>
</ul>
<div class="hlcode"><pre><span class="kt">int</span><span class="o">*</span> <span class="n">product</span> <span class="o">=</span><span class="k">new</span> <span class="n">product</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="n">product</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=~~</span>

<span class="n">function</span> <span class="p">(</span><span class="n">n</span><span class="p">){</span>

    <span class="k">return</span> <span class="n">function</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4 id="32">3.2 动规解题的一般思路：</h4>
<ol>
<li>将原问题分解为子问题 </li>
<li>把原问题分解为若干个子问题，子问题和原问题形式相同 或类似，只不过规模变小了。子问题都解决，原问题即解决。 </li>
<li>
<p>子问题的解一旦求出就会被保存，所以每个子问题只需求解一次</p>
</li>
<li>
<p>确定状态 </p>
</li>
</ol>
<p><code>状态</code>：在用动态规划解题时，我们往往将和子问题相关的各个变量的一组取值，称之为一个<code>状态</code>。<br />
<code>状态的值</code>:就是这个<code>状态</code>所对应的子问题的解</p>
<p><code>状态空间</code>所有<code>状态</code>的集合，构成问题的<code>状态空间</code></p>
<p><code>状态空间的大小</code>，与用动态规划解决问题的时间复杂度直接相关。</p>
<blockquote>
<p>在数字三角形的例子里，一共有N×(N+1)/2个数字，所以这个 问题的状态空间里一共就有N×(N+1)/2个状态。 </p>
</blockquote>
<p><code>整个问题的时间复杂度</code>是状态数目乘以计算每个状态所需时间。</p>
<blockquote>
<p>在数字三角形里每个“状态”只需要经过一次，且在每个 状态上作计算所花的时间都是和N无关的常数。 </p>
</blockquote>
<ol>
<li>
<p>确定一些初始状态（边界状态）的值 </p>
<p>以“数字三角形”为例，初始状态就是底边数字，值 就是底边数字值。 </p>
</li>
<li>
<p>确定状态转移方程 </p>
<p>定义出什么是“状态”，以及在该 “状态”下的“值”后，就要 找出不同的状态之间如何迁移――即如何从一个或多个“值”已知的 “状态”，求出另一个“状态”的“值”(“人人为我”递推型)。状 态的迁移可以用递推公式表示，此递推公式也可被称作“状态转移方 程”。       数字三角形的状态转移方程: </p>
</li>
</ol>
<p>可用用动态规矩解决的问题特点 <br />
 1) 问题具有最优子结构性质。如果问题的最优解所包含的 子问题的解也是最优的，我们就称该问题具有最优子结 构性质。<br />
 2)  无后效性。当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前是采取哪 种手段或经过哪条路径演变到当前的这若干个状态，没 有关系。 </p>
<p><img alt="avatar" src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d047ce29b?imageslim" /></p>
<h3 id="4">4. 深度优先搜索</h3>
<h4 id="41-dfs">4.1 dfs</h4>
<p><strong>说明:</strong><br />
此时所在的顶点 node<br />
候选节点 candidate_node_stack<br />
选择的节点 node_i</p>
<p><img alt="" src="https://cuijiahua.com/wp-content/uploads/2018/01/alogrithm_10_3.gif" /></p>
<div class="hlcode"><pre><span class="n">Dfs</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//可行性减支</span>
    <span class="k">if</span><span class="p">(</span><span class="n">node</span> <span class="err">访问过</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">;</span>  
    <span class="err">将</span><span class="n">node</span><span class="err">标记为访问过</span><span class="p">;</span>
    <span class="n">node</span><span class="err">相邻的点加入到</span><span class="n">candidate_node_stack</span> <span class="err">总</span>
    <span class="err">从</span><span class="n">candidate_node_stack</span><span class="err">里面确定下一个点</span><span class="n">node_i</span><span class="o">:</span>  
    <span class="n">Dfs</span><span class="p">(</span><span class="n">node_i</span><span class="p">);</span>
    <span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="err">在图中能找到未访问过的点</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">Dfs</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
    <span class="p">}</span> 
         <span class="p">}</span>
</pre></div>


<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Graph</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">node_neighbors</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">visited</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="k">def</span> <span class="nf">add_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nodelist</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodelist</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">node_neighbors</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">edge</span><span class="p">):</span>
    <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="o">=</span> <span class="n">edge</span>
    <span class="k">if</span><span class="p">(</span><span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_neighbors</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span> <span class="n">u</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_neighbors</span><span class="p">[</span><span class="n">v</span><span class="p">]):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">node_neighbors</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
      <span class="k">if</span><span class="p">(</span><span class="n">u</span><span class="o">!=</span><span class="n">v</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_neighbors</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_neighbors</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
  <span class="k">def</span> <span class="nf">depth_first_search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">root</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">order</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
      <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_neighbors</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">visited</span><span class="p">:</span>
          <span class="n">dfs</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">root</span><span class="p">:</span>
      <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">visited</span><span class="p">:</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">order</span>
    <span class="k">return</span> <span class="n">order</span>
  <span class="k">def</span> <span class="nf">breadth_first_search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">root</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">order</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="nf">bfs</span><span class="p">():</span>
      <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_neighbors</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
          <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">visited</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">):</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">root</span><span class="p">:</span>
      <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
      <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
      <span class="n">bfs</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">visited</span><span class="p">:</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">bfs</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">order</span>
    <span class="k">return</span> <span class="n">order</span>
</pre></div>


<h4 id="42">4.2  剪枝</h4>
<p>剪枝：把不会产生答案的，或不必要的枝条“剪掉”。</p>
<p>即在设计剪枝判断方法的基础上，避免一些不必要的遍历过程，从而提高算法效率。</p>
<h5 id="421">4.2.1 剪枝的关键</h5>
<p>剪枝的关键就在于剪枝的判断：<strong>什么枝该剪，什么枝不该剪，在什么地方减</strong>。</p>
<h5 id="422">4.2.2 剪枝的原则</h5>
<p>正确性，准确性，高效性。</p>
<h5 id="423">4.2.3 常用的剪枝</h5>
<h6 id="4231">4.2.3.1. 可行性剪枝</h6>
<blockquote>
<p>如果当前条件不合法就不再继续搜索，直接return。这是非常好理解的剪枝。一般的搜索都会加上。</p>
</blockquote>
<p>一般格式：</p>
<div class="hlcode"><pre><span class="n">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="o">&gt;</span><span class="n">n</span><span class="p">)</span><span class="k">return</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">check1</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="k">return</span><span class="p">;</span>
    <span class="p">....</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h6 id="4232">4.2.3.2. 最优性剪枝</h6>
<blockquote>
<p>如果当前条件所创造出的答案必定比之前的答案大，那么剩下的搜索就毫无必要，甚至可以剪掉。<br />
我们利用某个函数估计出此时条件下答案的‘下界’，将它与已经推出的答案相比，如果不比当前答案小，就可以剪掉。</p>
</blockquote>
<p>一般格式：</p>
<div class="hlcode"><pre><span class="kt">long</span> <span class="kt">long</span> <span class="n">ans</span><span class="o">=</span><span class="mi">987474477434487ll</span><span class="p">;</span>
<span class="n">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,...)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="p">...</span> <span class="o">&amp;&amp;</span> <span class="p">...)</span>
    <span class="p">{</span>
        <span class="n">ans</span><span class="o">=</span><span class="p">....;</span>
        <span class="k">return</span> <span class="p">...;</span>
    <span class="p">}</span>
    <span class="c1">//最优性剪枝 </span>
    <span class="k">if</span><span class="p">(</span><span class="n">check2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&gt;=</span><span class="n">ans</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">...;</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;...;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">vis</span><span class="p">[...]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> 
            <span class="n">dfs</span><span class="p">(...);</span>
            <span class="n">vis</span><span class="p">[...]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>一般实现：<br />
在搜索取和最大值时，如果后面的全部取最大仍然不比当前答案大就可以返回。<br />
在搜和最小时同理，可以预处理后缀最大/最小和进行快速查询。</p>
<h6 id="4233">4.2.3.3. 记忆化搜索</h6>
<p>记忆化搜索其实很像动态规划（DP）。</p>
<p>它的关键是：如果对于相同情况下必定答案相同，就可以把这个情况的答案值存储下来，以后再次搜索到这种情况时就可以直接调用。</p>
<p>还有就是不能搜出环来，不能互相依赖。</p>
<p>一般格式：</p>
<div class="hlcode"><pre><span class="kt">long</span> <span class="kt">long</span> <span class="n">ans</span><span class="o">=</span><span class="mi">987474477434487ll</span><span class="p">;</span>
<span class="n">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,...)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="p">...</span> <span class="o">&amp;&amp;</span> <span class="p">...)</span>
    <span class="p">{</span>
        <span class="n">ans</span><span class="o">=</span><span class="p">....;</span>
        <span class="k">return</span> <span class="p">...;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">vis</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
        <span class="n">vis</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;...;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">vis</span><span class="p">[...]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
            <span class="n">dfs</span><span class="p">(...);</span>
            <span class="n">vis</span><span class="p">[...]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
            <span class="n">f</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">=</span><span class="p">...;</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h6 id="4234">4.2.3.4. 搜索顺序剪枝</h6>
<p>在一些迷宫题，网格题，或者其他搜索中可以贪心的题，搜索顺序显得十分重要,好的顺序可以提高算法效率。</p>
<ol>
<li>在迷宫、网格类的题目中，右下左上就明显比左上右下优秀。</li>
<li>推断搜索题中，从已知信息最多的地方开始搜索显然更加优秀。</li>
<li>在一些题中，先搜某个值大的，再搜某个值小的(比如树的度数，产生答案的预计(A*))，速度明显会比乱搜更快。</li>
</ol>
<h3 id="5">5. 广度优先搜索</h3>
<h4 id="51">5.1 核心思想</h4>
<p>广索的基本方法是<strong>使用队列存放已经扩展过的节点</strong></p>
<p>适用问题:最短路径算法</p>
<p>此时所在的顶点 node<br />
候选节点 candidate_node_queue<br />
选择的节点 node_i</p>
<div class="hlcode"><pre><span class="n">BFS</span><span class="p">(){</span>
        <span class="err">初始化队列</span>
        <span class="k">while</span><span class="err">（队列不为空且未找到目标节点）</span> 
        <span class="p">{</span>
            <span class="err">取队首节点扩展，并将扩展出的非重复节点放入队尾</span> <span class="err">；</span>
            <span class="err">必要时记住每个节点的父节点；</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h3 id="6">6. 二分</h3>
<p>二分法是在<strong>有序或单调的区间</strong>中快速寻找答案的有效方法，当数据量很大适宜采用该方法。<br />
时间复杂度 O(logN)</p>
<h3 id="7">7. 贪心</h3>
<p>贪心（greedy algorithm）<br />
过程：</p>
<div class="hlcode"><pre><span class="mf">1.</span> <span class="err">建立数学模型来描述问题；</span>
<span class="mf">2.</span> <span class="err">把求解的问题分成若干个子问题；</span>
<span class="mf">3.</span> <span class="err">对每一子问题求解，得到子问题的局部最优解；</span>
<span class="mf">4.</span> <span class="err">把子问题的解局部最优解合成原来解问题的一个解。</span>
</pre></div>


<p>所谓贪心算法，即总是作出在当前看来最好的选择。也就是说贪心算法并不从整体最优考虑，它所作出的选择只是在某种意义上的局部最优选择。但是，贪心算法对很多问题都能得到整体最优解。在一些情况下，即使贪心算法不能得到整体最优解，其最终结果却是最优解的很好近似。贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。</p>
<h2 id="3_2">3.基于问题的划分</h2>
<h3 id="31_1">3.1 排序</h3>
<table>
<thead>
<tr>
<th align="right"></th>
<th align="right"></th>
<th align="right">复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">插入排序</td>
<td align="right">直接插入排序</td>
<td align="right">$O(n^2)$</td>
</tr>
<tr>
<td align="right">插入排序</td>
<td align="right">希尔排序</td>
<td align="right">$O(n\log n)$</td>
</tr>
<tr>
<td align="right">选择排序</td>
<td align="right">简单选择排序</td>
<td align="right">$O(n^2)$</td>
</tr>
<tr>
<td align="right">选择排序</td>
<td align="right">堆排序</td>
<td align="right">$O(n\log n)$</td>
</tr>
<tr>
<td align="right">交换排序</td>
<td align="right">冒泡排序</td>
<td align="right">$O(n^2)$</td>
</tr>
<tr>
<td align="right">交换排序</td>
<td align="right">快速排序</td>
<td align="right">$O(n\log n)$</td>
</tr>
<tr>
<td align="right">归并排序</td>
<td align="right">归并排序</td>
<td align="right">$O(n\log n)$</td>
</tr>
<tr>
<td align="right">* 记忆： 涉及二分/树 问题为 $O(nlogn)$</td>
<td align="right"></td>
<td align="right"></td>
</tr>
<tr>
<td align="right">#### 3.1.1. 插入排序</td>
<td align="right"></td>
<td align="right"></td>
</tr>
<tr>
<td align="right">#####  直接插入排序</td>
<td align="right"></td>
<td align="right"></td>
</tr>
</tbody>
</table>
<div class="hlcode"><pre><span class="c">##  插入排序</span>
<span class="c">### 打牌 拿牌的时候排序</span>
<span class="k">def</span> <span class="nf">insert_sort</span><span class="p">(</span><span class="n">raw_list</span><span class="p">):</span>
    <span class="c"># raw_list:[2,5,3,5 ]</span>
    <span class="c"># sorted_list:[2,5]</span>
    <span class="k">for</span> <span class="n">flag_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">raw_list</span><span class="p">)):</span>
        <span class="n">insert_value</span> <span class="o">=</span> <span class="n">raw_list</span><span class="p">[</span><span class="n">flag_index</span><span class="p">]</span>
        <span class="n">insert_index</span><span class="o">=</span><span class="n">flag_index</span>
        <span class="c"># insert_value:3</span>
        <span class="k">if</span> <span class="n">insert_value</span> <span class="o">&lt;</span> <span class="n">raw_list</span><span class="p">[</span><span class="n">flag_index</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c"># if 3 &lt; 5</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">insert_index</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>  <span class="c"># 对于  sorted_list</span>
                <span class="k">if</span> <span class="n">raw_list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">insert_value</span> <span class="p">:</span>
                    <span class="c"># if 5&gt;3</span>
                    <span class="n">raw_list</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">raw_list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="c"># </span>
                    <span class="n">insert_index</span> <span class="o">=</span> <span class="n">j</span>   <span class="c">#记录待插入下标</span>
                <span class="k">else</span> <span class="p">:</span>
                    <span class="k">break</span>
            <span class="n">raw_list</span><span class="p">[</span><span class="n">insert_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">insert_value</span>
        <span class="k">print</span> <span class="p">(</span><span class="s">&quot;flag_index {} 的 {}:{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">flag_index</span><span class="p">,</span><span class="n">raw_list</span><span class="p">[</span><span class="n">flag_index</span><span class="p">],</span><span class="n">raw_list</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">raw_list</span>

<span class="n">myList</span> <span class="o">=</span> <span class="p">[</span><span class="mi">49</span><span class="p">,</span><span class="mi">38</span><span class="p">,</span><span class="mi">65</span><span class="p">,</span><span class="mi">97</span><span class="p">,</span><span class="mi">76</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">27</span><span class="p">,</span><span class="mi">49</span><span class="p">]</span>
<span class="n">insert_sort</span><span class="p">(</span><span class="n">myList</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">myList</span><span class="p">)</span>


<span class="n">flag_index</span> <span class="mi">1</span> <span class="err">的</span> <span class="mi">49</span><span class="p">:[</span><span class="mi">38</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">97</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">49</span><span class="p">]</span>
<span class="n">flag_index</span> <span class="mi">2</span> <span class="err">的</span> <span class="mi">65</span><span class="p">:[</span><span class="mi">38</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">97</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">49</span><span class="p">]</span>
<span class="n">flag_index</span> <span class="mi">3</span> <span class="err">的</span> <span class="mi">97</span><span class="p">:[</span><span class="mi">38</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">97</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">49</span><span class="p">]</span>
<span class="n">flag_index</span> <span class="mi">4</span> <span class="err">的</span> <span class="mi">97</span><span class="p">:[</span><span class="mi">38</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">97</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">49</span><span class="p">]</span>
<span class="n">flag_index</span> <span class="mi">5</span> <span class="err">的</span> <span class="mi">97</span><span class="p">:[</span><span class="mi">13</span><span class="p">,</span> <span class="mi">38</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">97</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">49</span><span class="p">]</span>
<span class="n">flag_index</span> <span class="mi">6</span> <span class="err">的</span> <span class="mi">97</span><span class="p">:[</span><span class="mi">13</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">38</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">97</span><span class="p">,</span> <span class="mi">49</span><span class="p">]</span>
<span class="n">flag_index</span> <span class="mi">7</span> <span class="err">的</span> <span class="mi">97</span><span class="p">:[</span><span class="mi">13</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">38</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">97</span><span class="p">]</span>
</pre></div>


<h5 id="_3">希尔排序</h5>
<div class="hlcode"><pre><span class="c">#!/usr/bin/env python</span>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="c">#插入排序，缩小增量</span>
<span class="k">def</span> <span class="nf">shell_sort</span><span class="p">(</span><span class="n">raw_list</span><span class="p">):</span>
    <span class="n">gap</span> <span class="o">=</span> <span class="n">len_of_list</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">raw_list</span><span class="p">)</span>
    <span class="n">result_list</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">while</span><span class="p">(</span><span class="n">gap</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">gap</span> <span class="o">=</span> <span class="n">gap</span><span class="o">/</span><span class="mi">2</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">len_of_list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">len_of_list</span> <span class="o">-</span> <span class="n">gap</span><span class="p">,</span> <span class="n">gap</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">result_list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">result_list</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">gap</span><span class="p">]:</span>
                    <span class="n">result_list</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">result_list</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">gap</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_list</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">gap</span><span class="p">],</span> <span class="n">result_list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">result_list</span>
</pre></div>


<h4 id="312">3.1.2 选择排序</h4>
<h5 id="_4">简单选择排序</h5>
<div class="hlcode"><pre><span class="c">## 1.1 选择排序</span>
<span class="c">### 先选第一个，确定第一个最小，再确定第二个 </span>
<span class="k">def</span> <span class="nf">select_sort</span><span class="p">(</span><span class="n">raw_list</span><span class="p">):</span>
    <span class="n">sorted_list</span><span class="o">=</span><span class="n">raw_list</span>
    <span class="n">len_of_list</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">raw_list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">len_of_list</span><span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">selected_index</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">len_of_list</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sorted_list</span><span class="p">[</span><span class="n">selected_index</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">sorted_list</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">selected_index</span> <span class="o">=</span> <span class="n">j</span>
            <span class="n">sorted_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sorted_list</span><span class="p">[</span><span class="n">selected_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">sorted_list</span><span class="p">[</span><span class="n">selected_index</span><span class="p">],</span> <span class="n">sorted_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">print</span> <span class="p">(</span><span class="s">&quot;选择 {}:{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">raw_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">sorted_list</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">sorted_list</span>
<span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">select_sort</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="err">选择</span> <span class="mi">0</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="err">选择</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="err">选择</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="err">选择</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="err">选择</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="err">选择</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="err">选择</span> <span class="mi">6</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="err">选择</span> <span class="mi">7</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="err">选择</span> <span class="mi">8</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
</pre></div>


<h5 id="_5">堆排序</h5>
<div class="hlcode"><pre><span class="k">def</span> <span class="nf">heap_adjust</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>

    <span class="n">i</span> <span class="o">=</span> <span class="n">start</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span>

    <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">L</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]):</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">temp</span> <span class="o">&lt;</span> <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span>
            <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>

<span class="k">def</span> <span class="nf">heap_sort</span><span class="p">(</span><span class="n">raw_list</span><span class="p">):</span>
    <span class="n">len_of_list</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">raw_list</span><span class="p">)</span>

    <span class="n">first_sort_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">len_of_list</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">first_sort_count</span><span class="p">):</span>
        <span class="n">heap_adjust</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">first_sort_count</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">len_of_list</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">len_of_list</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">swap_param</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">len_of_list</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">heap_adjust</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">len_of_list</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">))]</span>
</pre></div>


<h4 id="313">3.1.3. 交换排序</h4>
<h5 id="_6">冒泡排序</h5>
<div class="hlcode"><pre><span class="c">## 1.3 交换排序</span>
<span class="k">def</span> <span class="nf">bubble_sort</span><span class="p">(</span><span class="n">raw_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;冒泡排序 相邻交换, 进行第几轮 最后面的第几个数值确定&quot;&quot;&quot;</span>
    <span class="k">print</span> <span class="p">(</span><span class="n">raw_list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">raw_list</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>    <span class="c"># 这个循环负责设置冒泡排序进行的次数</span>
        <span class="k">print</span> <span class="p">(</span><span class="s">&quot;交换前{}个数字 &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">raw_list</span><span class="p">)</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">raw_list</span><span class="p">)</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>  <span class="c"># ｊ为列表下标</span>
            <span class="k">if</span> <span class="n">raw_list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">raw_list</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">raw_list</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">raw_list</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">raw_list</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">raw_list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">print</span> <span class="p">(</span><span class="s">&quot;{}   {}&lt;-&gt;{} :{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">raw_list</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">raw_list</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">raw_list</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span> <span class="p">(</span><span class="s">&quot;{}   {} --{}: FALSE&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">raw_list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">,</span><span class="n">raw_list</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">raw_list</span>

<span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">bubble_sort</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

<span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="err">交换前</span><span class="mi">6</span><span class="err">个数字</span> 
<span class="mi">0</span>   <span class="mi">2</span><span class="o">&lt;-&gt;</span><span class="mi">5</span> <span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="mi">1</span>   <span class="mi">4</span><span class="o">&lt;-&gt;</span><span class="mi">5</span> <span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="mi">2</span>   <span class="mi">5</span> <span class="o">--</span><span class="mi">6</span><span class="p">:</span> <span class="n">FALSE</span>
<span class="mi">3</span>   <span class="mi">6</span> <span class="o">--</span><span class="mi">8</span><span class="p">:</span> <span class="n">FALSE</span>
<span class="mi">4</span>   <span class="mi">2</span><span class="o">&lt;-&gt;</span><span class="mi">8</span> <span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="mi">5</span>   <span class="mi">1</span><span class="o">&lt;-&gt;</span><span class="mi">8</span> <span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="err">交换前</span><span class="mi">5</span><span class="err">个数字</span> 
<span class="mi">0</span>   <span class="mi">2</span> <span class="o">--</span><span class="mi">4</span><span class="p">:</span> <span class="n">FALSE</span>
<span class="mi">1</span>   <span class="mi">4</span> <span class="o">--</span><span class="mi">5</span><span class="p">:</span> <span class="n">FALSE</span>
<span class="mi">2</span>   <span class="mi">5</span> <span class="o">--</span><span class="mi">6</span><span class="p">:</span> <span class="n">FALSE</span>
<span class="mi">3</span>   <span class="mi">2</span><span class="o">&lt;-&gt;</span><span class="mi">6</span> <span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="mi">4</span>   <span class="mi">1</span><span class="o">&lt;-&gt;</span><span class="mi">6</span> <span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="err">交换前</span><span class="mi">4</span><span class="err">个数字</span> 
<span class="mi">0</span>   <span class="mi">2</span> <span class="o">--</span><span class="mi">4</span><span class="p">:</span> <span class="n">FALSE</span>
<span class="mi">1</span>   <span class="mi">4</span> <span class="o">--</span><span class="mi">5</span><span class="p">:</span> <span class="n">FALSE</span>
<span class="mi">2</span>   <span class="mi">2</span><span class="o">&lt;-&gt;</span><span class="mi">5</span> <span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="mi">3</span>   <span class="mi">1</span><span class="o">&lt;-&gt;</span><span class="mi">5</span> <span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="err">交换前</span><span class="mi">3</span><span class="err">个数字</span> 
<span class="mi">0</span>   <span class="mi">2</span> <span class="o">--</span><span class="mi">4</span><span class="p">:</span> <span class="n">FALSE</span>
<span class="mi">1</span>   <span class="mi">2</span><span class="o">&lt;-&gt;</span><span class="mi">4</span> <span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="mi">2</span>   <span class="mi">1</span><span class="o">&lt;-&gt;</span><span class="mi">4</span> <span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="err">交换前</span><span class="mi">2</span><span class="err">个数字</span> 
<span class="mi">0</span>   <span class="mi">2</span> <span class="o">--</span><span class="mi">2</span><span class="p">:</span> <span class="n">FALSE</span>
<span class="mi">1</span>   <span class="mi">1</span><span class="o">&lt;-&gt;</span><span class="mi">2</span> <span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="err">交换前</span><span class="mi">1</span><span class="err">个数字</span> 
<span class="mi">0</span>   <span class="mi">1</span><span class="o">&lt;-&gt;</span><span class="mi">2</span> <span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
</pre></div>


<h5 id="_7">快速排序</h5>
<div class="hlcode"><pre><span class="c"># 快速排序</span>
<span class="c">## 1.取基准值</span>
<span class="c">## 2. 确保基准值 左&lt;右</span>
<span class="k">def</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="n">raw_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;快速排序&quot;&quot;&quot;</span> 
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">raw_list</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>  <span class="c"># 递归入口及出口</span>
        <span class="n">pivot</span> <span class="o">=</span> <span class="n">raw_list</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">raw_list</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>  <span class="c"># 选取基准值，也可以选取第一个或最后一个元素      </span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>  <span class="c"># 定义基准值左右两侧的列表</span>
        <span class="n">raw_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">pivot</span><span class="p">)</span>  <span class="c"># 从原始数组中移除基准值</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">raw_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;=</span> <span class="n">pivot</span><span class="p">:</span>
                <span class="n">right</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">left</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        <span class="n">sorted_list</span><span class="o">=</span><span class="n">quick_sort</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="o">+</span> <span class="n">quick_sort</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>    
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sorted_list</span><span class="o">=</span><span class="n">raw_list</span>
    <span class="k">return</span> <span class="n">sorted_list</span>
<span class="c"># 示例：</span>
<span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="n">quick_sort</span><span class="p">(</span><span class="n">array</span><span class="p">))</span>

<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">15</span><span class="p">]</span>
</pre></div>


<h4 id="314">3.1.4 归并排序</h4>
<div class="hlcode"><pre>
</pre></div>


<h3 id="32_1">3.2 查找</h3>
<h4 id="321">3.2.1. 二分查找</h4>
<p>针对已经排好序的数据结构，从中间开始查找，比较大小<br />
时间复杂度O(logN)</p>
<h4 id="322">3.2.2. 顺序查找</h4>
<p>时间负责度O(n)</p>
<h4 id="323">3.2.3 哈希表查找</h4>
<p>时间复杂度 O(1)</p>
<h4 id="324">3.2.4 二叉搜索树查找</h4>
<h3 id="33">3.3 图的搜索</h3>
<h4 id="331">3.3.1 树的遍历</h4>
<h5 id="3311">3.3.1.1 前序</h5>
<h5 id="3312">3.3.1.2 中序</h5>
<h5 id="3313">3.3.1.3 后序</h5>
<h4 id="332">3.3.2 广度优先搜索</h4>
<h4 id="333">3.3.3 深度优先搜索</h4>
<h1 id="_8">参考资料</h1>
<p>[1] 我的第一步算法书 <br />
[2] 5分钟</p>
</div>
<div id="renote">
  <HR style=" FILTER: alpha (opacity = 100, finishopacity =0 , style= 3 )" width="80%" color=#987 cb 9 SIZE=3>
  <p>如果你觉得这篇文章对你有帮助，不妨请我喝杯咖啡，鼓励我创造更多!</p>
  <img src="/Wiki/static/images/pay.jpg" width="25%">
</div>

    </div>
    <div id="footer">
        <span>
            Copyright © 2021 zhang787jun.
            Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.
        </span>
    </div>

    
</body>
<script>
    function changeImgurl(site_root_url) {
        var images = document.images;
        var site_root = site_root_url;
        for (i = 0, len = images.length; i < len; i++) {
            image = images[i];
            image_src = image.src;
            if (image_src.search("attach") >= 0) {
                re_image_src = image_src.slice(image_src.search("attach"));
                abs_image_src = (site_root.endsWith("/")) ? site_root + re_image_src : site_root + "/" +
                    re_image_src;
                image.src = abs_image_src;
            }
        }
    }
    var site_root_url = "/Wiki";
    changeImgurl(site_root_url);
    let isMathjaxConfig = false; // 防止重复调用Config，造成性能损耗
    const initMathjaxConfig = () => {
        if (!window.MathJax) {
            return;
        }
        window.MathJax.Hub.Config({
            showProcessingMessages: false, //关闭js加载过程信息
            messageStyle: "none", //不显示信息
            jax: ["input/TeX", "output/HTML-CSS"],
            tex2jax: {
                inlineMath: [["$", "$"], ["\\(", "\\)"]], //行内公式选择符
                displayMath: [["$$", "$$"], ["\\[", "\\]"]], //段内公式选择符
                skipTags: ["script", "noscript", "style", "textarea", "pre", "code", "a"] //避开某些标签
            },
            "HTML-CSS": {
                availableFonts: ["STIX", "TeX"], //可选字体
                showMathMenu: false //关闭右击菜单显示
            }
        });
        isMathjaxConfig = true; //
    };
    if (isMathjaxConfig === false) {
        // 如果：没有配置MathJax
        initMathjaxConfig();
    };
</script>

</html>