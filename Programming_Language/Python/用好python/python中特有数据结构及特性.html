<!DOCTYPE HTML>
<html>

<head>
    <link rel="Stylesheet" type="text/css" href="/Wiki/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/Wiki/static/css/tango.css">
    <link rel="shortcut icon" href="/Wiki/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/Wiki/favicon.ico" type="image/x-icon">
    <title>Python中特有数据结构及特性 - Jun's personal knowledge wiki</title>
    <meta name="keywords" content="Technology, MachineLearning, DataMining, Wiki" />
    <meta name="description" content="A wiki website" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
            }
        });
    </script>
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
        </script>
</head>

<body>

    <div id="container">
        
<div id="header">
  <div id="post-nav"><a href="/Wiki/">Home</a>&nbsp;»&nbsp;<a href="/Wiki/#Programming_Language">Programming_Language</a>&nbsp;»&nbsp;<a href="/Wiki/#-Python">Python</a>&nbsp;»&nbsp;<a href="/Wiki/#-用好python">用好python</a>&nbsp;»&nbsp;Python中特有数据结构及特性</div>
</div>
<div class="clearfix"></div>
<div id="title">Python中特有数据结构及特性</div>
<div id="content">
  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#1-python">1. python 实现经典数据结构</a></li>
<li><a href="#2-dict">2. dict 字典</a></li>
<li><a href="#3-with">3. with 上下文管理器</a></li>
<li><a href="#4">4. 高阶函数</a><ul>
<li><a href="#41-map">4.1. map</a></li>
<li><a href="#42-sorted">4.2. sorted</a></li>
</ul>
</li>
<li><a href="#5-1">5. 修饰器@ 1</a><ul>
<li><a href="#51">5.1. 基本定性</a></li>
<li><a href="#52">5.2. 详解</a><ul>
<li><a href="#521">5.2.1. 简单修饰器</a></li>
<li><a href="#522">5.2.2. 内置修饰器</a><ul>
<li><a href="#5221-staticmethod">5.2.2.1. @staticmethod</a></li>
<li><a href="#5222-classmethod-">5.2.2.2. @classmethod--类方法</a></li>
<li><a href="#5223-property-">5.2.2.3. @property--属性</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#53">5.3. 进阶修饰器</a><ul>
<li><a href="#531">5.3.1. 原函数有参数传入</a><ul>
<li><a href="#5311">5.3.1.1. 原函数有确定参数输入</a></li>
<li><a href="#5312">5.3.1.2. 原函数可变参数输入</a></li>
<li><a href="#5313">5.3.1.3. 原函数字典参数输入</a></li>
</ul>
</li>
<li><a href="#532">5.3.2. 装饰器有参数传入</a></li>
</ul>
</li>
<li><a href="#54">5.4. 装饰器顺序</a></li>
<li><a href="#55">5.5. 装饰器类</a></li>
</ul>
</li>
<li><a href="#6-class">6. Class 类</a></li>
<li><a href="#7">7. 魔方方法</a></li>
<li><a href="#8-collections">8. collections 集合</a></li>
<li><a href="#10-abc">10. abc</a></li>
<li><a href="#11">11. 参考资料</a></li>
</ul>
</div>
<h1 id="1-python">1. python 实现经典数据结构</h1>
<p>参考：https://github.com/TheAlgorithms/Python/tree/master/data_structures</p>
<h1 id="2-dict">2. dict 字典</h1>
<p>字典的数据结构本质是hash table<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup></p>
<p>冲突处理，当key的集合很大的时候，根据生日问题（birthday problem）原理，哈希冲突实际上是不可避免的，所以几乎所有的哈希表都会有对于冲突的解决策略，常见的方法有三种;<br />
    1）拉链法（separate chaining）：也被称为开放散列法（open hashing）或封闭定址法（closed addressing）<br />
    2）开放定址法（open addressing），也被称为封闭散列（closed hashing）<br />
    3）建立公共溢出区（building a public overflow area）<br />
4）其他方法：<br />
        ①联合哈希法（coalesced hashing）<br />
        ②疯狂哈希法（cuckoo hashing）<br />
        ③跳房子哈希法（hopscotch hashing）<br />
        ④罗宾汉哈希法（robin hood hashing）<br />
        ⑤二选哈希法（2-choice hashing）</p>
<div class="hlcode"><pre><span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;a&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;b&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;c&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">}</span>
<span class="c">#python&gt;=3.6 ： key有序,按输入顺序</span>
<span class="n">a</span>
<span class="o">&gt;&gt;&gt;</span> 
<span class="p">{</span><span class="s">&#39;a&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;b&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;c&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">}</span>
<span class="c">#python&lt;=3.6 ：key无序</span>
<span class="n">a</span>
<span class="o">&gt;&gt;&gt;</span> 
<span class="p">{</span><span class="s">&#39;a&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>

<span class="c">#python 任意版本 set 无序</span>

<span class="nb">set</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="p">{</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">}</span>
</pre></div>


<p>Python3.6 之前的Hash实现是基于Open Addressing（开放定址法）的。类似C++中的unordered_map, 当你搜索所有的key的时候，实际上就是遍历整个表，寻找那些value不为null的entry，然后把它们的key放到一个list里面，这个 过程自然是不保证顺序的。</p>
<p>Python 3.6改写了dict的内部算法，因此3.6的dict是有序的，在此版本之前皆是无序（写答案当前最新版为3.6）可参考阅读PEP 468根据PEP 468，此项改进降低了dict的内存消耗大概20%-25%（对比Python 3.5）。</p>
<p>Python 3.6改写了dict的内部算法，因此3.6的dict是有序的，在此版本之前皆是无序（写答案当前最新版为3.6）可参考阅读PEP 468根据PEP 468，此项改进降低了dict的内存消耗大概20%-25%（对比Python 3.5）注意3.6的dict遵循的顺序是Key的插入顺序。</p>
<p>也就是说需要用一定顺序插入才能获得排好的结果，否则依然需要sort。另外，同样是Hash表实现的set在3.6里也依然是无序状态，这个没改最后，低版本希望有序dict可以用<code>collections.OrderedDict</code>。这是早在2.7就实装了的容器。它同样是遵循插入顺序。</p>
<div class="hlcode"><pre><span class="c">#!/usr/bin/python3</span>

<span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;Name&#39;</span><span class="p">:</span> <span class="s">&#39;Runoob&#39;</span><span class="p">,</span> <span class="s">&#39;Age&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">}</span>
<span class="n">dict2</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;Sex&#39;</span><span class="p">:</span> <span class="s">&#39;female&#39;</span> <span class="p">}</span>

<span class="nb">dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dict2</span><span class="p">)</span>
<span class="k">print</span> <span class="p">(</span><span class="s">&quot;更新字典 dict : &quot;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span>
<span class="err">更新字典</span> <span class="nb">dict</span> <span class="p">:</span>  <span class="p">{</span><span class="s">&#39;Name&#39;</span><span class="p">:</span> <span class="s">&#39;Runoob&#39;</span><span class="p">,</span> <span class="s">&#39;Age&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="s">&#39;Sex&#39;</span><span class="p">:</span> <span class="s">&#39;female&#39;</span><span class="p">}</span>
</pre></div>


<h1 id="3-with">3. with 上下文管理器</h1>
<div class="hlcode"><pre><span class="k">with</span> <span class="err">上下文管理器对象：</span>
    　<span class="err">语句体</span>

<span class="nb">dir</span><span class="p">(</span><span class="err">上下文管理器对象</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="o">...</span>
<span class="n">__enter__</span>
<span class="n">__exit__</span>
<span class="o">...</span>
</pre></div>


<p>当with遇到上下文管理器对象，就会在执行语句体之前，先执行上下文管理器对象的<code>__enter__</code>方法，然后再执行语句体，执行完语句体后，最后执行<code>__exit__</code>方法</p>
<h1 id="4">4. 高阶函数</h1>
<p>什么是<strong>高阶函数</strong>？（不是高级函数）<br />
把函数名当做参数传给另外一个函数，在另外一个函数中通过参数调用执行</p>
<div class="hlcode"><pre><span class="c">#!/usr/bin/python3</span>

<span class="k">def</span> <span class="nf">func_x</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>

<span class="k">def</span> <span class="nf">func_y</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">y</span> <span class="o">*</span> <span class="mi">3</span>

<span class="k">def</span> <span class="nf">func_z</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="c"># 等价于 return func_x(5) + func_y(3)</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c"># 把函数当做参数，本质上是把函数的内存地址当做参数传递过去，</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">func_z</span><span class="p">(</span><span class="n">func_x</span><span class="p">,</span> <span class="n">func_y</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>


<h3 id="41-map">4.1. map</h3>
<h3 id="42-sorted">4.2. sorted</h3>
<h1 id="5-1">5. 修饰器@ <sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup></h1>
<p><strong>函数就是用来写core 函数的</strong>--路飞</p>
<h3 id="51">5.1. 基本定性</h3>
<p>装饰器本质上是一个高级Python函数，通过给别的函数添加@标识的形式实现对函数的装饰，这个函数的特殊之处在于它的返回值也是一个函数</p>
<p><strong>优势：</strong><br />
1. 可以让其他函数在不需要做任何代码变动的前提下增加额外功能</p>
<p><strong>应用场景：</strong></p>
<p>经常用于有切面需求的场景，例如: <br />
1. 插入日志<br />
2. 性能测试<br />
3. 事务处理<br />
4. 缓存<br />
5. 权限校验等场景</p>
<p>有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。</p>
<h3 id="52">5.2. 详解</h3>
<h4 id="521">5.2.1. 简单修饰器</h4>
<p><strong>3个关键函数</strong></p>
<p>关于 decorator, 基本上一共有三个函数:<br />
1. decorator: 修饰器/修饰函数<br />
2. orifunc: 原函数/被修饰函数<br />
3. wrapper: 新函数/取代函数/闭包函数</p>
<p>简单的可以标识为:</p>
<div class="hlcode"><pre><span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">orifunc</span><span class="p">):</span>
    <span class="c"># do something here (register...)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c"># do something before (preprocess)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">orifunc</span><span class="p">()</span>
        <span class="c"># do something after (postprocess)</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>


<p>它们的关系是:</p>
<div class="hlcode"><pre><span class="n">wrapper</span> <span class="o">=</span> <span class="n">decorator</span><span class="p">(</span><span class="n">orifunc</span><span class="p">)</span>
</pre></div>


<p>上述表示等同于</p>
<div class="hlcode"><pre><span class="nd">@decorator</span>
<span class="k">def</span> <span class="nf">orifunc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c"># do something...</span>
</pre></div>


<p><strong>执行顺序</strong></p>
<div class="hlcode"><pre><span class="k">def</span> <span class="nf">Timer</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">newFunc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">args2</span><span class="p">):</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
        <span class="k">print</span> <span class="p">(</span><span class="s">&quot;[1]&quot;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">args2</span><span class="p">)</span>
        <span class="n">t2</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
        <span class="k">print</span> <span class="p">(</span><span class="s">&quot;[3]&quot;</span><span class="p">)</span>
        <span class="n">cost_time</span><span class="o">=</span><span class="n">t2</span><span class="o">-</span><span class="n">t1</span>
        <span class="k">print</span> <span class="p">(</span><span class="s">&quot; This function【{}】cost time:{} </span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span><span class="n">cost_time</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">newFunc</span>

<span class="nd">@Timer</span>
<span class="k">def</span> <span class="nf">Pi</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="c">#N=10**7</span>
    <span class="n">N</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">data</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">inside</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">data</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">pi</span><span class="o">=</span><span class="mi">4</span><span class="o">*</span><span class="n">inside</span><span class="o">/</span><span class="n">N</span>
    <span class="k">print</span> <span class="p">(</span><span class="s">&quot;[2] pi is </span><span class="si">%.5f</span><span class="s">&quot;</span><span class="o">%</span><span class="n">pi</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> 
<span class="s">&quot;[1]&quot;</span>
<span class="s">&quot;[2]  pi is 3.1415&quot;</span>
<span class="s">&quot;[3]&quot;</span>
<span class="s">&quot;This function Pi cost time:{}&quot;</span>
</pre></div>


<h4 id="522">5.2.2. 内置修饰器</h4>
<p>修饰器可以自定义，同时，python中也有自定义的几个修饰器<br />
内置的装饰器有三个，分别是staticmethod、classmethod和property，作用分别是把类中定义的实例方法变成静态方法、类方法和类属性。</p>
<p>使用频率也非常低。</p>
<h5 id="5221-staticmethod">5.2.2.1. @staticmethod</h5>
<h5 id="5222-classmethod-">5.2.2.2. @classmethod--类方法</h5>
<h5 id="5223-property-">5.2.2.3. @property--属性</h5>
<p>在绑定类属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改：</p>
<div class="hlcode"><pre><span class="n">s</span> <span class="o">=</span> <span class="n">Student</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="mi">9999</span> <span class="c"># 成绩不能大于100 ，参数值不合理 </span>
</pre></div>


<p>这显然不合逻辑。<strong>为了限制score的范围</strong>，可以通过一个set_score()方法来设置成绩，再通过一个get_score()来获取成绩，这样，在set_score()方法里，就可以检查参数：</p>
<div class="hlcode"><pre><span class="n">class</span> <span class="n">Student</span><span class="p">(</span><span class="n">object</span><span class="p">)</span><span class="o">:</span>
    <span class="n">def</span> <span class="n">get_score</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">:</span>
         <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">_score</span>

    <span class="n">def</span> <span class="n">set_score</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span><span class="o">:</span>
        <span class="k">if</span> <span class="n">not</span> <span class="n">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">:</span>
            <span class="n">raise</span> <span class="n">ValueError</span><span class="p">(</span><span class="err">&#39;</span><span class="n">score</span> <span class="n">must</span> <span class="n">be</span> <span class="n">an</span> <span class="n">integer</span><span class="o">!</span><span class="err">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="n">or</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="o">:</span>
            <span class="n">raise</span> <span class="n">ValueError</span><span class="p">(</span><span class="err">&#39;</span><span class="n">score</span> <span class="n">must</span> <span class="n">between</span> <span class="mi">0</span> <span class="o">~</span> <span class="mi">100</span><span class="o">!</span><span class="err">&#39;</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">_score</span> <span class="o">=</span> <span class="n">value</span>
</pre></div>


<p>还记得装饰器（decorator）可以给函数动态加上功能吗？对于类的方法，装饰器一样起作用。Python内置的@property装饰器就是负责把一个方法变成属性调用的：</p>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Student</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score</span>

    <span class="nd">@score.setter</span>
    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;score must be an integer!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;score must between 0 ~ 100!&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_score</span> <span class="o">=</span> <span class="n">value</span>
</pre></div>


<p>@property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作：</p>
<p>还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性：</p>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Student</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">birth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_birth</span>

    <span class="nd">@birth.setter</span>
    <span class="k">def</span> <span class="nf">birth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_birth</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">age</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">2015</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_birth</span>
</pre></div>


<p>上面的birth是可读写属性，而age就是一个只读属性，因为age可以根据birth和当前时间计算出来</p>
<h3 id="53">5.3. 进阶修饰器</h3>
<h4 id="531">5.3.1. 原函数有参数传入</h4>
<p>python 中函数的参数分为<br />
1.必选参数<br />
2.默认参数<br />
3.可变参数 <em>args  仅仅在参数前面加了一个</em>号。<br />
4.关键字参数 **kw</p>
<h6 id="5311">5.3.1.1. 原函数有确定参数输入</h6>
<div class="hlcode"><pre><span class="c"># 非语法糖</span>
<span class="k">def</span> <span class="nf">use_logging</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> is running&quot;</span> <span class="o">%</span> <span class="n">func</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>   <span class="c"># 把 orifunc 当做参数传递进来时，执行func()就相当于执行 orifunc()</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="k">def</span> <span class="nf">orifunc</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;i am {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
<span class="c"># 因为装饰器 use_logging(foo) 返回的时函数对象 wrapper，这条语句相当于  orifunc = wrapper</span>
<span class="c"># orifunc()就相当于执行 wrapper()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">orifunc</span> <span class="o">=</span> <span class="n">use_logging</span><span class="p">(</span><span class="n">orifunc</span><span class="p">)</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="n">orifunc</span><span class="p">(</span><span class="s">&quot;me&quot;</span><span class="p">)</span>


<span class="c"># 语法糖</span>
<span class="k">def</span> <span class="nf">use_logging</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> is running&quot;</span> <span class="o">%</span> <span class="n">func</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="nd">@use_logging</span>
<span class="k">def</span> <span class="nf">orifunc</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;i am {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">orifunc</span><span class="p">(</span><span class="s">&quot;me&quot;</span><span class="p">)</span>
</pre></div>


<h6 id="5312">5.3.1.2. 原函数可变参数输入</h6>
<div class="hlcode"><pre><span class="c">#------[2] 参数列表输入</span>


<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;i am </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> is running&quot;</span> <span class="o">%</span> <span class="n">func</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>


<h6 id="5313">5.3.1.3. 原函数字典参数输入</h6>
<div class="hlcode"><pre><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;I am </span><span class="si">%s</span><span class="s">, age </span><span class="si">%s</span><span class="s">, height </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">height</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c"># args是一个数组，kwargs一个字典</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> is running&quot;</span> <span class="o">%</span> <span class="n">func</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>


<h4 id="532">5.3.2. 装饰器有参数传入</h4>
<p>有多种方式让装饰器接受可选参数。根据你是想使用位置参数、关键字参数还是两者皆是，需要使用稍微不同的模式。如下我将展示一种接受一个可选关键字参数的方式：<br />
1.定义3层闭包<br />
2.Layer 1 最外层形参用来接收装饰器参数<br />
3.Layer 2 第二层用来接受被修饰的原函数<br />
4.Layer 3 第三层用来传递原函数的参数</p>
<div class="hlcode"><pre><span class="k">def</span> <span class="nf">nominally_decorator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kw</span><span class="p">):</span>       
    <span class="c"># Layer 1  *args,**kw 为nominally_decorator的参数</span>
    <span class="k">def</span> <span class="nf">core_decorator</span><span class="p">(</span><span class="n">orifunc</span><span class="p">):</span>           
        <span class="c"># Layer 2 第二层用来接受被修饰的原函数</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">arguments_for_orifunc</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_for_orifunc</span><span class="p">):</span> 
            <span class="c"># Layer 3 Layer 3 第三层用来传递原函数的参数</span>

            <span class="c"># do something before (preprocess)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">orifunc</span><span class="p">(</span><span class="o">*</span><span class="n">arguments_for_orifunc</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_for_orifunc</span><span class="p">)</span>
            <span class="c"># do something after (postprocess)</span>

            <span class="k">return</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">wrapper</span>
    <span class="k">return</span> <span class="n">core_decorator</span>
</pre></div>


<div class="hlcode"><pre><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="k">def</span> <span class="nf">typeassert</span><span class="p">(</span><span class="o">*</span><span class="n">ty_args</span><span class="p">,</span> <span class="o">**</span><span class="n">ty_kwargs</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorate</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="c"># If in optimized mode, disable type checking 关闭类型检测模式</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">__debug__</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">func</span>
        <span class="c"># 通过signature方法，获取函数形参：name, age, height</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="n">bound_types</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">bind_partial</span><span class="p">(</span><span class="o">*</span><span class="n">ty_args</span><span class="p">,</span> <span class="o">**</span><span class="n">ty_kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">arguments</span>

        <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">bound_values</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c"># Enforce type assertions across supplied arguments</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">bound_values</span><span class="o">.</span><span class="n">arguments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">bound_types</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">bound_types</span><span class="p">[</span><span class="n">name</span><span class="p">]):</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="s">&#39;Argument {} must be {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bound_types</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
                            <span class="p">)</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper</span>
    <span class="k">return</span> <span class="n">decorate</span>
</pre></div>


<h3 id="54">5.4. 装饰器顺序</h3>
<p>一个函数还可以同时定义多个装饰器，比如：</p>
<div class="hlcode"><pre><span class="nd">@a</span>
<span class="nd">@b</span>
<span class="nd">@c</span>
<span class="k">def</span> <span class="nf">f</span> <span class="p">():</span>
    <span class="k">pass</span>
</pre></div>


<p>它的执行顺序是从里到外，最先调用最里层的装饰器，最后调用最外层的装饰器，它等效于</p>
<div class="hlcode"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">a</span><span class="p">(</span><span class="n">b</span><span class="p">(</span><span class="n">c</span><span class="p">(</span><span class="n">f</span><span class="p">)))</span>
</pre></div>


<h3 id="55">5.5. 装饰器类</h3>
<p>不仅装饰器可以装饰一个类，并且装饰器也可以是一个类！对于装饰器的唯一要求就是它的返回值必须可调用(callable)。这意味着装饰器必须实现 <strong>call</strong> 魔术方法，当你调用一个对象时，会隐式调用这个方法。函数当然是隐式设置这个方法的。我们重新将 identity_decorator 创建为一个类来看看它是如何工作的。</p>
<p>类装饰器<br />
接下来我们用面对对象的方法实现装饰器的功能，你应该有python面对对象编程的基础，这里面会用到魔法方法。</p>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Decrator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fn</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;初始化函数&quot;</span><span class="p">,</span><span class="n">fn</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_func</span> <span class="o">=</span> <span class="n">fn</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;打印的内容&quot;</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="nd">@Decrator</span>
<span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>

<span class="k">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="err">执行结果</span>

<span class="err">初始化函数</span> <span class="nb">sum</span>
<span class="err">打印的内容</span> <span class="mi">3</span> <span class="mi">3</span>
<span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">Decrator</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x0000024986FF7198</span><span class="o">&gt;</span>
</pre></div>


<p>解析：函数sum定义前加上@Decorator，相当于实例化类对象<code>Decorator(sum)</code>，同时初始化实例属性self._func=sum函数;接下来实例对象后加上()，会调用实例对象的__call__方法，打印出内容和参数，然后返回实例属性即sum函数并执行函数计算x+y。</p>
<h1 id="6-class">6. Class 类</h1>
<div class="hlcode"><pre><span class="n">obj</span> <span class="o">=</span> <span class="mi">12</span> 
<span class="c"># obj can be an object from any class, even object.__new__(object)</span>

<span class="k">class</span> <span class="nc">returnExistedObj</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;__new__ is called&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">__init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;__init__ is called&quot;</span><span class="p">)</span>

<span class="n">returnExistedObj</span><span class="p">()</span>

<span class="err">执行结果如下：</span>
<span class="n">__new__</span> <span class="ow">is</span> <span class="n">called</span>
<span class="mi">12</span>

<span class="err">同时另一个需要注意的点是：</span>
<span class="err">如果我们在</span><span class="n">__new__</span><span class="err">函数中不返回任何对象，则</span><span class="n">__init__</span><span class="err">函数也不会被调用。</span>
<span class="err">如下面代码所示：</span>
<span class="k">class</span> <span class="nc">notReturnObj</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;__new__ is called&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;__init__ is called&quot;</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">notReturnObj</span><span class="p">())</span>

<span class="err">执行结果如下：</span>
<span class="n">__new__</span> <span class="ow">is</span> <span class="n">called</span>
<span class="bp">None</span>

<span class="err">可见如果</span><span class="n">__new__</span><span class="err">函数不返回对象的话，不会有任何对象被创建，</span><span class="n">__init__</span><span class="err">函数也不会被调用来初始化对象。</span>
<span class="err">总结几个点</span>

<span class="n">__init__</span><span class="err">不能有返回值</span>
<span class="n">__new__</span><span class="err">函数直接上可以返回别的类的实例。如上面例子中的</span><span class="n">returnExistedObj</span><span class="err">类的</span><span class="n">__new__</span><span class="err">函数返回了一个</span><span class="n">int</span><span class="err">值。</span>
<span class="err">只有在</span><span class="n">__new__</span><span class="err">返回一个新创建属于该类的实例时当前类的</span><span class="n">__init__</span><span class="err">才会被调用。如下面例子所示：</span>
</pre></div>


<h1 id="7">7. 魔方方法</h1>
<p>什么是Python魔法方法?<br />
魔法方法就如同它的名字一样神奇，总能在你需要的时候为你提供某种方法来让你的想法实现。魔法方法是指Python内部已经包含的，被双下划线所包围的方法，这些方法在进行特定的操作时会自动被调用，它们是Python面向对象下智慧的结晶。初学者掌握Python的魔法方法也就变得尤为重要了。</p>
<p>为什么要使用Python魔法方法?</p>
<p>使用Python的魔法方法可以使Python的自由度变得更高，当不需要重写时魔法方法也可以在规定的默认情况下生效，在需要重写时也可以让使用者根据自己的需求来重写部分方法来达到自己的期待。而且众所周知Python是支持面向对象的语言Python的基本魔法方法就使得Python在面对对象方面做得更好。</p>
<div class="hlcode"><pre><span class="err">基础魔法方法（较为常用）</span>

<span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">[,</span> <span class="o">...</span><span class="p">])</span> <span class="err">才是实例化对象调用的第一个方法，它只取下</span> <span class="n">cls</span> <span class="err">参数，并把其他参数传给</span> <span class="n">__init__</span><span class="err">。</span> <span class="n">__new__</span><span class="err">很少使用，但是也有它适合的场景</span><span class="p">(</span><span class="err">单例模式</span><span class="p">)</span><span class="err">，尤其是当类继承自一个像元组或者字符串这样不经常改变的类型的时候。</span>

<span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">[,</span> <span class="o">...</span><span class="p">])</span><span class="err">构造方法，初始化类的时候被调用</span>

<span class="n">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="err">析构方法，当实例化对象被彻底销毁时被调用（实例化对象的所有指针都被销毁时被调用）</span>

<span class="n">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">[,</span> <span class="n">args</span><span class="o">...</span><span class="p">])</span><span class="err">允许一个类的实例像函数一样被调用：</span><span class="n">x</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="err">调用</span> <span class="n">x</span><span class="o">.</span><span class="n">__call__</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

<span class="n">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="err">定义当被</span> <span class="nb">len</span><span class="p">()</span> <span class="err">调用时的行为</span><span class="n">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="err">定义当被</span> <span class="nb">repr</span><span class="p">()</span> <span class="err">调用时的行为</span>

<span class="n">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="err">定义当被</span> <span class="nb">str</span><span class="p">()</span> <span class="err">调用时的行为</span><span class="n">__bytes__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="err">定义当被</span> <span class="nb">bytes</span><span class="p">()</span> <span class="err">调用时的行为</span>

<span class="n">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="err">定义当被</span> <span class="nb">hash</span><span class="p">()</span> <span class="err">调用时的行为</span>

<span class="n">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="err">定义当被</span> <span class="nb">bool</span><span class="p">()</span> <span class="err">调用时的行为，应该返回</span> <span class="bp">True</span> <span class="err">或</span> <span class="bp">False</span>

<span class="n">__format__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format_spec</span><span class="p">)</span><span class="err">定义当被</span> <span class="n">format</span><span class="p">()</span> <span class="err">调用时的行为</span>



<span class="err">属性相关的方法</span>

<span class="n">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="err">定义当用户试图获取一个不存在的属性时的行为</span>

<span class="n">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="err">定义当该类的属性被访问时的行为</span>

<span class="n">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span><span class="err">定义当一个属性被设置时的行为</span>

<span class="n">__delattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="err">定义当一个属性被删除时的行为</span>

<span class="n">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="err">定义当</span> <span class="nb">dir</span><span class="p">()</span> <span class="err">被调用时的行为</span>

<span class="n">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">)</span><span class="err">定义当描述符的值被取得时的行为</span>

<span class="n">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span><span class="err">定义当描述符的值被改变时的行为</span>

<span class="n">__delete__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">)</span><span class="err">定义当描述符的值被删除时的行为</span>



<span class="err">比较操作符</span>

<span class="n">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="err">定义小于号的行为：</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="err">调用</span> <span class="n">x</span><span class="o">.</span><span class="n">__lt__</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

<span class="n">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="err">定义小于等于号的行为：</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="err">调用</span> <span class="n">x</span><span class="o">.</span><span class="n">__le__</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

<span class="n">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="err">定义等于号的行为：</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="err">调用</span> <span class="n">x</span><span class="o">.</span><span class="n">__eq__</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

<span class="n">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="err">定义不等号的行为：</span><span class="n">x</span> <span class="o">!=</span> <span class="n">y</span> <span class="err">调用</span> <span class="n">x</span><span class="o">.</span><span class="n">__ne__</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

<span class="n">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="err">定义大于号的行为：</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="err">调用</span> <span class="n">x</span><span class="o">.</span><span class="n">__gt__</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

<span class="n">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="err">定义大于等于号的行为：</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">y</span> <span class="err">调用</span> <span class="n">x</span><span class="o">.</span><span class="n">__ge__</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>



<span class="err">类型转换</span>

<span class="n">__complex__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="err">定义当被</span> <span class="nb">complex</span><span class="p">()</span> <span class="err">调用时的行为（需要返回恰当的值）</span>

<span class="n">__int__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="err">定义当被</span> <span class="nb">int</span><span class="p">()</span> <span class="err">调用时的行为（需要返回恰当的值）</span>

<span class="n">__float__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="err">定义当被</span> <span class="nb">float</span><span class="p">()</span> <span class="err">调用时的行为（需要返回恰当的值）</span><span class="n">__round__</span><span class="p">(</span><span class="bp">self</span><span class="p">[,</span> <span class="n">n</span><span class="p">])</span><span class="err">定义当被</span> <span class="nb">round</span><span class="p">()</span> <span class="err">调用时的行为（需要返回恰当的值）</span>



<span class="err">容器类型（一般用于操作容器类）</span>

<span class="n">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="err">定义当被</span> <span class="nb">len</span><span class="p">()</span> <span class="err">调用时的行为（一般返回容器类的长度）</span>

<span class="n">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span><span class="err">定义获取容器中指定元素的行为，相当于</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

<span class="n">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span><span class="err">定义设置容器中指定元素的行为，相当于</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

<span class="n">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span><span class="err">定义删除容器中指定元素的行为，相当于</span> <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

<span class="n">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="err">定义当迭代容器中的元素的行为</span>

<span class="n">__reversed__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="err">定义当被</span> <span class="nb">reversed</span><span class="p">()</span> <span class="err">调用时的行为</span>

<span class="n">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span><span class="err">定义当使用成员测试运算符（</span><span class="ow">in</span> <span class="err">或</span> <span class="ow">not</span> <span class="ow">in</span><span class="err">）时的行为</span>
</pre></div>


<h1 id="8-collections">8. collections 集合</h1>
<p>collections是Python内建的一个集合模块，提供了许多有用的集合类。</p>
<p>OrderedDict 也是 dict 的子类，其最大特征是，它可以“维护”添加 key-value 对的顺序。简单来说，就是先添加的 key-value 对排在前面，后添加的 key-value 对排在后面。</p>
<div class="hlcode"><pre><span class="n">namedtuple</span>
<span class="err">我们知道</span><span class="n">tuple</span><span class="err">可以表示不变集合，例如，一个点的二维坐标就可以表示成：</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="err">但是，看到</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="err">，很难看出这个</span><span class="n">tuple</span><span class="err">是用来表示一个坐标的。</span>

<span class="err">定义一个</span><span class="n">class</span><span class="err">又小题大做了，这时，</span><span class="n">namedtuple</span><span class="err">就派上了用场：</span>

<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Point</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">&#39;Point&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span><span class="o">.</span><span class="n">x</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span>
<span class="mi">2</span>
<span class="n">namedtuple</span><span class="err">是一个函数，它用来创建一个自定义的</span><span class="n">tuple</span><span class="err">对象，并且规定了</span><span class="n">tuple</span><span class="err">元素的个数，并可以用属性而不是索引来引用</span><span class="n">tuple</span><span class="err">的某个元素。</span>

<span class="err">这样一来，我们用</span><span class="n">namedtuple</span><span class="err">可以很方便地定义一种数据类型，它具备</span><span class="n">tuple</span><span class="err">的不变性，又可以根据属性来引用，使用十分方便。</span>

<span class="err">可以验证创建的</span><span class="n">Point</span><span class="err">对象是</span><span class="n">tuple</span><span class="err">的一种子类：</span>

<span class="o">&gt;&gt;&gt;</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Point</span><span class="p">)</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
<span class="bp">True</span>
<span class="err">类似的，如果要用坐标和半径表示一个圆，也可以用</span><span class="n">namedtuple</span><span class="err">定义：</span>

<span class="c"># 2. namedtuple(&#39;名称&#39;, [属性list]):</span>
<span class="n">Circle</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">&#39;Circle&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">])</span>
<span class="n">deque</span>
<span class="err">使用</span><span class="n">list</span><span class="err">存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为</span><span class="n">list</span><span class="err">是线性存储，数据量大的时候，插入和删除效率很低。</span>

<span class="n">deque</span><span class="err">是为了高效实现插入和删除操作的双向列表，适合用于队列和栈：</span>

<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q</span>
<span class="n">deque</span><span class="p">([</span><span class="s">&#39;y&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="s">&#39;x&#39;</span><span class="p">])</span>
<span class="n">deque</span><span class="err">除了实现</span><span class="n">list</span><span class="err">的</span><span class="n">append</span><span class="p">()</span><span class="err">和</span><span class="n">pop</span><span class="p">()</span><span class="err">外，还支持</span><span class="n">appendleft</span><span class="p">()</span><span class="err">和</span><span class="n">popleft</span><span class="p">()</span><span class="err">，这样就可以非常高效地往头部添加或删除元素。</span>

<span class="n">defaultdict</span>
<span class="err">使用</span><span class="n">dict</span><span class="err">时，如果引用的</span><span class="n">Key</span><span class="err">不存在，就会抛出</span><span class="ne">KeyError</span><span class="err">。如果希望</span><span class="n">key</span><span class="err">不存在时，返回一个默认值，就可以用</span><span class="n">defaultdict</span><span class="err">：</span>

<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dd</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="s">&#39;N/A&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dd</span><span class="p">[</span><span class="s">&#39;key1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;abc&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dd</span><span class="p">[</span><span class="s">&#39;key1&#39;</span><span class="p">]</span> <span class="c"># key1存在</span>
<span class="s">&#39;abc&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dd</span><span class="p">[</span><span class="s">&#39;key2&#39;</span><span class="p">]</span> <span class="c"># key2不存在，返回默认值</span>
<span class="s">&#39;N/A&#39;</span>
<span class="err">注意默认值是调用函数返回的，而函数在创建</span><span class="n">defaultdict</span><span class="err">对象时传入。</span>

<span class="err">除了在</span><span class="n">Key</span><span class="err">不存在时返回默认值，</span><span class="n">defaultdict</span><span class="err">的其他行为跟</span><span class="n">dict</span><span class="err">是完全一样的。</span>

<span class="n">OrderedDict</span>
<span class="err">使用</span><span class="n">dict</span><span class="err">时，</span><span class="n">Key</span><span class="err">是无序的。在对</span><span class="n">dict</span><span class="err">做迭代时，我们无法确定</span><span class="n">Key</span><span class="err">的顺序。</span>

<span class="err">如果要保持</span><span class="n">Key</span><span class="err">的顺序，可以用</span><span class="n">OrderedDict</span><span class="err">：</span>

<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="c"># dict的Key是无序的</span>
<span class="p">{</span><span class="s">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">od</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">od</span> <span class="c"># OrderedDict的Key是有序的</span>
<span class="n">OrderedDict</span><span class="p">([(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="err">注意，</span><span class="n">OrderedDict</span><span class="err">的</span><span class="n">Key</span><span class="err">会按照插入的顺序排列，不是</span><span class="n">Key</span><span class="err">本身排序：</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">od</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">od</span><span class="p">[</span><span class="s">&#39;z&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">od</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">od</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">list</span><span class="p">(</span><span class="n">od</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="c"># 按照插入的Key的顺序返回</span>
<span class="p">[</span><span class="s">&#39;z&#39;</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">,</span> <span class="s">&#39;x&#39;</span><span class="p">]</span>
<span class="n">OrderedDict</span><span class="err">可以实现一个</span><span class="n">FIFO</span><span class="err">（先进先出）的</span><span class="nb">dict</span><span class="err">，当容量超出限制时，先删除最早添加的</span><span class="n">Key</span><span class="err">：</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>

<span class="k">class</span> <span class="nc">LastUpdatedOrderedDict</span><span class="p">(</span><span class="n">OrderedDict</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">capacity</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LastUpdatedOrderedDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_capacity</span> <span class="o">=</span> <span class="n">capacity</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">containsKey</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="n">containsKey</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_capacity</span><span class="p">:</span>
            <span class="n">last</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">popitem</span><span class="p">(</span><span class="n">last</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;remove:&#39;</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">containsKey</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;set:&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;add:&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
        <span class="n">OrderedDict</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="n">ChainMap</span>
<span class="n">ChainMap</span><span class="err">可以把一组</span><span class="n">dict</span><span class="err">串起来并组成一个逻辑上的</span><span class="nb">dict</span><span class="err">。</span><span class="n">ChainMap</span><span class="err">本身也是一个</span><span class="nb">dict</span><span class="err">，但是查找的时候，会按照顺序在内部的</span><span class="n">dict</span><span class="err">依次查找。</span>

<span class="err">什么时候使用</span><span class="n">ChainMap</span><span class="err">最合适？举个例子：应用程序往往都需要传入参数，参数可以通过命令行传入，可以通过环境变量传入，还可以有默认参数。我们可以用</span><span class="n">ChainMap</span><span class="err">实现参数的优先级查找，即先查命令行参数，如果没有传入，再查环境变量，如果没有，就使用默认参数。</span>

<span class="err">下面的代码演示了如何查找</span><span class="n">user</span><span class="err">和</span><span class="n">color</span><span class="err">这两个参数：</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">ChainMap</span>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">argparse</span>

<span class="c"># 3. 构造缺省参数:</span>
<span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;color&#39;</span><span class="p">:</span> <span class="s">&#39;red&#39;</span><span class="p">,</span>
    <span class="s">&#39;user&#39;</span><span class="p">:</span> <span class="s">&#39;guest&#39;</span>
<span class="p">}</span>

<span class="c"># 4. 构造命令行参数:</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;-u&#39;</span><span class="p">,</span> <span class="s">&#39;--user&#39;</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;-c&#39;</span><span class="p">,</span> <span class="s">&#39;--color&#39;</span><span class="p">)</span>
<span class="n">namespace</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
<span class="n">command_line_args</span> <span class="o">=</span> <span class="p">{</span> <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">(</span><span class="n">namespace</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="p">}</span>

<span class="c"># 5. 组合成ChainMap:</span>
<span class="n">combined</span> <span class="o">=</span> <span class="n">ChainMap</span><span class="p">(</span><span class="n">command_line_args</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">,</span> <span class="n">defaults</span><span class="p">)</span>

<span class="c"># 6. 打印参数:</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;color=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">combined</span><span class="p">[</span><span class="s">&#39;color&#39;</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;user=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">combined</span><span class="p">[</span><span class="s">&#39;user&#39;</span><span class="p">])</span>
<span class="err">没有任何参数时，打印出默认参数：</span>

<span class="err">$</span> <span class="n">python3</span> <span class="n">use_chainmap</span><span class="o">.</span><span class="n">py</span> 
<span class="n">color</span><span class="o">=</span><span class="n">red</span>
<span class="n">user</span><span class="o">=</span><span class="n">guest</span>
<span class="err">当传入命令行参数时，优先使用命令行参数：</span>

<span class="err">$</span> <span class="n">python3</span> <span class="n">use_chainmap</span><span class="o">.</span><span class="n">py</span> <span class="o">-</span><span class="n">u</span> <span class="n">bob</span>
<span class="n">color</span><span class="o">=</span><span class="n">red</span>
<span class="n">user</span><span class="o">=</span><span class="n">bob</span>
<span class="err">同时传入命令行参数和环境变量，命令行参数的优先级较高：</span>

<span class="err">$</span> <span class="n">user</span><span class="o">=</span><span class="n">admin</span> <span class="n">color</span><span class="o">=</span><span class="n">green</span> <span class="n">python3</span> <span class="n">use_chainmap</span><span class="o">.</span><span class="n">py</span> <span class="o">-</span><span class="n">u</span> <span class="n">bob</span>
<span class="n">color</span><span class="o">=</span><span class="n">green</span>
<span class="n">user</span><span class="o">=</span><span class="n">bob</span>
<span class="n">Counter</span>
<span class="n">Counter</span><span class="err">是一个简单的计数器，例如，统计字符出现的个数：</span>

<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="s">&#39;programming&#39;</span><span class="p">:</span>
<span class="o">...</span>     <span class="n">c</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span>
<span class="n">Counter</span><span class="p">({</span><span class="s">&#39;g&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;m&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;i&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;o&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;n&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;p&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="n">Counter</span><span class="err">实际上也是</span><span class="n">dict</span><span class="err">的一个子类，上面的结果可以看出，字符</span><span class="s">&#39;g&#39;</span><span class="err">、</span><span class="s">&#39;m&#39;</span><span class="err">、</span><span class="s">&#39;r&#39;</span><span class="err">各出现了两次，其他字符各出现了一次。</span>
</pre></div>


<p>小结<br />
collections模块提供了一些有用的集合类，可以根据需要选用。</p>
<p>Python作为一个“内置电池”的编程语言，标准库里面拥有非常多好用的模块。比如今天想给大家 介绍的 collections 就是一个非常好的例子。<br />
基本介绍</p>
<p>我们都知道，Python拥有一些内置的数据类型，比如str, int, list, tuple, dict等， collections模块在这些内置数据类型的基础上，提供了几个额外的数据类型：</p>
<div class="hlcode"><pre><span class="n">namedtuple</span><span class="p">()</span><span class="o">:</span> <span class="err">生成可以使用名字来访问元素内容的</span><span class="n">tuple</span><span class="err">子类</span>
<span class="nl">deque:</span> <span class="err">双端队列，可以快速的从另外一侧追加和推出对象</span>
<span class="nl">Counter:</span> <span class="err">计数器，主要用来计数</span>
<span class="nl">OrderedDict:</span> <span class="err">有序字典</span>
<span class="nl">defaultdict:</span> <span class="err">带有默认值的字典</span>
</pre></div>


<p>namedtuple()</p>
<p>namedtuple主要用来产生可以使用名称来访问元素的数据对象，通常用来增强代码的可读性， 在访问一些tuple类型的数据时尤其好用。<br />
举个栗子</p>
<h1 id="10-abc">10. abc</h1>
<p>abc --- 抽象基类<br />
源代码： Lib/abc.py</p>
<p>该模块提供了在 Python 中定义 抽象基类 (ABC) 的组件，在 PEP 3119 中已有概述。查看 PEP 文档了解为什么需要在 Python 中增加这个模块。（也可查看 PEP 3141 以及 numbers 模块了解基于 ABC 的数字类型继承关系。）</p>
<p>collections 模块中有一些派生自 ABC 的具体类；当然这些类还可以进一步被派生。此外，collections.abc 子模块中有一些 ABC 可被用于测试一个类或实例是否提供特定的接口，例如它是否可哈希或它是否为映射等。</p>
<p>该模块提供了一个元类 ABCMeta，可以用来定义抽象类，另外还提供一个工具类 ABC，可以用它以继承的方式定义抽象基类。</p>
<p>class abc.ABC<br />
一个使用 ABCMeta 作为元类的工具类。抽象基类可</p>
<h1 id="11">11. 参考资料</h1>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>理解 Python 装饰器看这一篇就够了<br />
https://foofish.net/python-decorator.html&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>wiki 哈希表 https://en.wikipedia.org/wiki/Hash_table&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>
</div>
<div id="renote">
  <HR style=" FILTER: alpha (opacity = 100, finishopacity =0 , style= 3 )" width="80%" color=#987 cb 9 SIZE=3>
  <p>如果你觉得这篇文章对你有帮助，不妨请我喝杯咖啡，鼓励我创造更多!</p>
  <img src="/Wiki/static/images/pay.jpg" width="25%">
</div>

    </div>
    <div id="footer">
        <span>
            Copyright © 2021 zhang787jun.
            Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.
        </span>
    </div>

    
</body>
<script>
    function changeImgurl(site_root_url) {
        var images = document.images;
        var site_root = site_root_url;
        for (i = 0, len = images.length; i < len; i++) {
            image = images[i];
            image_src = image.src;
            if (image_src.search("attach") >= 0) {
                re_image_src = image_src.slice(image_src.search("attach"));
                abs_image_src = (site_root.endsWith("/")) ? site_root + re_image_src : site_root + "/" +
                    re_image_src;
                image.src = abs_image_src;
            }
        }
    }
    var site_root_url = "/Wiki";
    changeImgurl(site_root_url);
    let isMathjaxConfig = false; // 防止重复调用Config，造成性能损耗
    const initMathjaxConfig = () => {
        if (!window.MathJax) {
            return;
        }
        window.MathJax.Hub.Config({
            showProcessingMessages: false, //关闭js加载过程信息
            messageStyle: "none", //不显示信息
            jax: ["input/TeX", "output/HTML-CSS"],
            tex2jax: {
                inlineMath: [["$", "$"], ["\\(", "\\)"]], //行内公式选择符
                displayMath: [["$$", "$$"], ["\\[", "\\]"]], //段内公式选择符
                skipTags: ["script", "noscript", "style", "textarea", "pre", "code", "a"] //避开某些标签
            },
            "HTML-CSS": {
                availableFonts: ["STIX", "TeX"], //可选字体
                showMathMenu: false //关闭右击菜单显示
            }
        });
        isMathjaxConfig = true; //
    };
    if (isMathjaxConfig === false) {
        // 如果：没有配置MathJax
        initMathjaxConfig();
    };
</script>

</html>