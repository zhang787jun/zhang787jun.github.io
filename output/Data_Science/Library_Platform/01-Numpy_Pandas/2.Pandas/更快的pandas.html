<!DOCTYPE HTML>
<html>

<head>
    <link rel="Stylesheet" type="text/css" href="/Wiki/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/Wiki/static/css/tango.css">
    <link rel="shortcut icon" href="/Wiki/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/Wiki/favicon.ico" type="image/x-icon">
    <title>为了更快的 Pandas - Jun's personal knowledge wiki</title>
    <meta name="keywords" content="Technology, MachineLearning, DataMining, Wiki" />
    <meta name="description" content="A wiki website" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
            }
        });
    </script>
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
        </script>
</head>

<body>

    <div id="container">
        
<div id="header">
  <div id="post-nav"><a href="/Wiki/">Home</a>&nbsp;»&nbsp;<a href="/Wiki/#Data_Science\Library_Platform\01-Numpy_Pandas\2.Pandas">Data_Science\Library_Platform\01-Numpy_Pandas\2.Pandas</a>&nbsp;»&nbsp;为了更快的 Pandas</div>
</div>
<div class="clearfix"></div>
<div id="title">为了更快的 Pandas</div>
<div id="content">
  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#1">1. 使用更快的内核</a><ul>
<li><a href="#11-cython">1.1. 使用Cython</a></li>
<li><a href="#12-numba">1.2. 使用  numba</a></li>
<li><a href="#13-numpy-mkl">1.3. 更快的numpy内核--mkl 加速</a></li>
</ul>
</li>
<li><a href="#2-pandas">2. 更高效的使用pandas</a><ul>
<li><a href="#21-io">2.1. 高效数据IO</a><ul>
<li><a href="#211-pandas">2.1.1. 使用pandas自带函数读取文件</a></li>
<li><a href="#212-io">2.1.2. 使用二进制格式文件进行I/O</a><ul>
<li><a href="#2121-hdf5-format">2.1.2.1. HDF5 Format</a></li>
<li><a href="#2122-feather">2.1.2.2. feather</a></li>
<li><a href="#2123-parquet-">2.1.2.3. parquet--推荐</a></li>
<li><a href="#2124-python-pickle-format">2.1.2.4. Python Pickle Format</a></li>
<li><a href="#_1">比较</a></li>
</ul>
</li>
<li><a href="#213">2.1.3. 数据压缩后再进行持久化</a></li>
</ul>
</li>
<li><a href="#22-">2.2. 高效遍历数据--避免常规循环</a><ul>
<li><a href="#221-x1">2.2.1. 标准遍历--x1</a></li>
<li><a href="#222-iterrows-x321">2.2.2. 使用内置函数 iterrows()--x321倍加速</a></li>
<li><a href="#223-apply-x811">2.2.3. 使用内置函数 apply()--x811倍加速</a></li>
<li><a href="#224-groupby-">2.2.4. 使用groupby()--减少遍历元素</a><ul>
<li><a href="#2241-groupbyapplyfunc">2.2.4.1. groupby().apply(func)</a></li>
<li><a href="#2242-groupbyaggfunc">2.2.4.2. groupby().agg(func)</a></li>
<li><a href="#2243-groupbytransformfunc">2.2.4.3. groupby().transform(func)</a></li>
<li><a href="#2244-groupby">2.2.4.4. groupby().内置函数</a></li>
</ul>
</li>
<li><a href="#225-groupbyapplynumpy">2.2.5. 更快的groupby.apply()方法，使用numpy 自定义</a></li>
<li><a href="#226-npvectorizeapply">2.2.6. 使用向量化函数 np.vectorize代替apply 处理</a></li>
<li><a href="#227-pandas-x9280">2.2.7. 使用pandas 向量化 —-x9280倍加速</a></li>
<li><a href="#228-numpy-x658880">2.2.8. 使用numpy 向量化--x658880倍加速</a></li>
<li><a href="#229">2.2.9. 总结</a></li>
</ul>
</li>
<li><a href="#23">2.3. 高效数据拼接</a><ul>
<li><a href="#231-append">2.3.1. 避免 append</a></li>
<li><a href="#232-join-merge-x8">2.3.2. join 代替 merge--x8加速</a></li>
</ul>
</li>
<li><a href="#24">2.4. 高效索引</a><ul>
<li><a href="#241">2.4.1. 使用层次化索引筛选数据，避免使用条件逻辑筛选</a></li>
<li><a href="#242-locilocixat">2.4.2. 正确使用 loc\iloc\ix\at</a></li>
<li><a href="#243-copy-vs-view">2.4.3. copy vs view</a></li>
</ul>
</li>
<li><a href="#25-numpy-numpy">2.5. 能改成numpy 就numpy</a></li>
<li><a href="#26">2.6. 多线程并行计算</a><ul>
<li><a href="#261-multiprocessingpool">2.6.1. multiprocessing.Pool</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-pandas">3. 更小的pandas</a><ul>
<li><a href="#31">3.1. 降低数据精度</a><ul>
<li><a href="#311">3.1.1. 数据读取时</a></li>
<li><a href="#312">3.1.2. 优化数据结构</a><ul>
<li><a href="#3121">3.1.2.1. 稀疏矩阵</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#32">3.2. 优化字符串对象</a><ul>
<li><a href="#321">3.2.1. 字符串内存占用组成</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-numpy">4. 使用numpy 代替</a></li>
<li><a href="#5">5. 参考资料</a></li>
</ul>
</div>
<h1 id="1">1. 使用更快的内核</h1>
<h2 id="11-cython">1.1. 使用Cython</h2>
<p>在jupyter notebook 中使用 Cython magic function<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup> 可以加速X3倍，对高度使用pandas的代码优化效果不明显。</p>
<p><strong>原理</strong><br />
对python 代码转C进行提前编译，对for 循环等python解释器执行的代码进行优化，对高度使用pandas的代码优化效果不明显。</p>
<div class="hlcode"><pre><span class="c"># Cell 1</span>
<span class="o">%</span><span class="n">load_ext</span> <span class="n">Cython</span>

<span class="c"># Cell 2</span>
<span class="c">## 注意需要添加相应的依赖项/包</span>
<span class="o">%%</span><span class="n">cython</span>
<span class="kn">import</span> <span class="nn">package</span>
<span class="k">def</span> <span class="nf">fun_name</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="n">boo</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">res</span> 
<span class="c"># Cell 3</span>
<span class="n">df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">fun_name</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>


<h2 id="12-numba">1.2. 使用  numba</h2>
<p>numba.njit：更高的效率<br />
当循环被认为可行时，通常会通过numba底层的NumPy数组对其进行优化，以尽可能多地移至C。</p>
<p>实际上，将numba性能提高到了微秒。没有一些繁琐的工作，将很难获得比这更高的效率。</p>
<div class="hlcode"><pre><span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">njit</span>

<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">divide</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">res</span>

<span class="o">%</span><span class="n">timeit</span> <span class="n">divide</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="s">&#39;B&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>  <span class="c"># 717 µs</span>
</pre></div>


<p>使用@njit(parallel=True)可以为更大的阵列提供进一步的提升</p>
<h2 id="13-numpy-mkl">1.3. 更快的numpy内核--mkl 加速</h2>
<p><img alt="" src="/attach/images/2019-10-27-13-56-37.png" /></p>
<p>英特尔数学核心库(Intel MKL) 的开发是致力于加速在intel处理器上进行的数学运算。该库支持 Windows, Linux and macOS 操作系统。</p>
<p><strong>安装</strong></p>
<div class="hlcode"><pre><span class="n">pip</span> <span class="n">install</span> <span class="n">intel</span><span class="o">-</span><span class="n">numpy</span>

<span class="n">conda</span> <span class="n">install</span> <span class="n">numpy</span> <span class="err">#</span> <span class="n">conda</span> <span class="err">版本已经是优化过的</span> <span class="n">Anoconda</span> <span class="err">（</span><span class="n">base</span><span class="err">）环境里面已经安装过</span> 
</pre></div>


<p><strong>查看</strong></p>
<div class="hlcode"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span> 
<span class="n">np</span><span class="o">.</span><span class="n">show_config</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="c"># No MKL</span>
<span class="n">blas_mkl_info</span><span class="p">:</span>
  <span class="n">NOT</span> <span class="n">AVAILABLE</span>
<span class="n">blis_info</span><span class="p">:</span>
  <span class="n">NOT</span> <span class="n">AVAILABLE</span>
<span class="n">openblas_info</span><span class="p">:</span>
    <span class="n">library_dirs</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;C:</span><span class="se">\\</span><span class="s">projects</span><span class="se">\\</span><span class="s">numpy-wheels</span><span class="se">\\</span><span class="s">numpy</span><span class="se">\\</span><span class="s">build</span><span class="se">\\</span><span class="s">openblas&#39;</span><span class="p">]</span>
    <span class="n">libraries</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;openblas&#39;</span><span class="p">]</span>
    <span class="n">language</span> <span class="o">=</span> <span class="n">f77</span>
    <span class="n">define_macros</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;HAVE_CBLAS&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)]</span>
<span class="n">blas_opt_info</span><span class="p">:</span>
    <span class="n">library_dirs</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;C:</span><span class="se">\\</span><span class="s">projects</span><span class="se">\\</span><span class="s">numpy-wheels</span><span class="se">\\</span><span class="s">numpy</span><span class="se">\\</span><span class="s">build</span><span class="se">\\</span><span class="s">openblas&#39;</span><span class="p">]</span>
    <span class="n">libraries</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;openblas&#39;</span><span class="p">]</span>
    <span class="n">language</span> <span class="o">=</span> <span class="n">f77</span>
    <span class="n">define_macros</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;HAVE_CBLAS&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)]</span>
<span class="n">lapack_mkl_info</span><span class="p">:</span>
  <span class="n">NOT</span> <span class="n">AVAILABLE</span>
<span class="n">openblas_lapack_info</span><span class="p">:</span>
    <span class="n">library_dirs</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;C:</span><span class="se">\\</span><span class="s">projects</span><span class="se">\\</span><span class="s">numpy-wheels</span><span class="se">\\</span><span class="s">numpy</span><span class="se">\\</span><span class="s">build</span><span class="se">\\</span><span class="s">openblas&#39;</span><span class="p">]</span>
    <span class="n">libraries</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;openblas&#39;</span><span class="p">]</span>
    <span class="n">language</span> <span class="o">=</span> <span class="n">f77</span>
    <span class="n">define_macros</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;HAVE_CBLAS&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)]</span>
<span class="n">lapack_opt_info</span><span class="p">:</span>
    <span class="n">library_dirs</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;C:</span><span class="se">\\</span><span class="s">projects</span><span class="se">\\</span><span class="s">numpy-wheels</span><span class="se">\\</span><span class="s">numpy</span><span class="se">\\</span><span class="s">build</span><span class="se">\\</span><span class="s">openblas&#39;</span><span class="p">]</span>
    <span class="n">libraries</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;openblas&#39;</span><span class="p">]</span>
    <span class="n">language</span> <span class="o">=</span> <span class="n">f77</span>
    <span class="n">define_macros</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;HAVE_CBLAS&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)]</span>

<span class="c"># with mkl</span>
<span class="n">mkl_info</span><span class="p">:</span>
    <span class="n">libraries</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;mkl_rt&#39;</span><span class="p">]</span>
    <span class="n">library_dirs</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;D:/ProgramData/Anaconda3</span><span class="se">\\</span><span class="s">Library</span><span class="se">\\</span><span class="s">lib&#39;</span><span class="p">]</span>
    <span class="n">define_macros</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;SCIPY_MKL_H&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;HAVE_CBLAS&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)]</span>
    <span class="n">include_dirs</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;C:</span><span class="se">\\</span><span class="s">Program Files (x86)</span><span class="se">\\</span><span class="s">IntelSWTools</span><span class="se">\\</span><span class="s">compilers_and_libraries_2019.0.117</span><span class="se">\\</span><span class="s">windows</span><span class="se">\\</span><span class="s">mkl&#39;</span><span class="p">,</span> <span class="s">&#39;C:</span><span class="se">\\</span><span class="s">Program Files (x86)</span><span class="se">\\</span><span class="s">IntelSWTools</span><span class="se">\\</span><span class="s">compilers_and_libraries_2019.0.117</span><span class="se">\\</span><span class="s">windows</span><span class="se">\\</span><span class="s">mkl</span><span class="se">\\</span><span class="s">include&#39;</span><span class="p">,</span> <span class="s">&#39;C:</span><span class="se">\\</span><span class="s">Program Files (x86)</span><span class="se">\\</span><span class="s">IntelSWTools</span><span class="se">\\</span><span class="s">compilers_and_libraries_2019.0.117</span><span class="se">\\</span><span class="s">windows</span><span class="se">\\</span><span class="s">mkl</span><span class="se">\\</span><span class="s">lib&#39;</span><span class="p">,</span> <span class="s">&#39;D:/ProgramData/Anaconda3</span><span class="se">\\</span><span class="s">Library</span><span class="se">\\</span><span class="s">include&#39;</span><span class="p">]</span>      
<span class="n">blas_mkl_info</span><span class="p">:</span>
    <span class="n">libraries</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;mkl_rt&#39;</span><span class="p">]</span>
    <span class="n">library_dirs</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;D:/ProgramData/Anaconda3</span><span class="se">\\</span><span class="s">Library</span><span class="se">\\</span><span class="s">lib&#39;</span><span class="p">]</span>
    <span class="n">define_macros</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;SCIPY_MKL_H&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;HAVE_CBLAS&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)]</span>
    <span class="n">include_dirs</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;C:</span><span class="se">\\</span><span class="s">Program Files (x86)</span><span class="se">\\</span><span class="s">IntelSWTools</span><span class="se">\\</span><span class="s">compilers_and_libraries_2019.0.117</span><span class="se">\\</span><span class="s">windows</span><span class="se">\\</span><span class="s">mkl&#39;</span><span class="p">,</span> <span class="s">&#39;C:</span><span class="se">\\</span><span class="s">Program Files (x86)</span><span class="se">\\</span><span class="s">IntelSWTools</span><span class="se">\\</span><span class="s">compilers_and_libraries_2019.0.117</span><span class="se">\\</span><span class="s">windows</span><span class="se">\\</span><span class="s">mkl</span><span class="se">\\</span><span class="s">include&#39;</span><span class="p">,</span> <span class="s">&#39;C:</span><span class="se">\\</span><span class="s">Program Files (x86)</span><span class="se">\\</span><span class="s">IntelSWTools</span><span class="se">\\</span><span class="s">compilers_and_libraries_2019.0.117</span><span class="se">\\</span><span class="s">windows</span><span class="se">\\</span><span class="s">mkl</span><span class="se">\\</span><span class="s">lib&#39;</span><span class="p">,</span> <span class="s">&#39;D:/ProgramData/Anaconda3</span><span class="se">\\</span><span class="s">Library</span><span class="se">\\</span><span class="s">include&#39;</span><span class="p">]</span>      
<span class="n">blas_opt_info</span><span class="p">:</span>
    <span class="n">libraries</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;mkl_rt&#39;</span><span class="p">]</span>
    <span class="n">library_dirs</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;D:/ProgramData/Anaconda3</span><span class="se">\\</span><span class="s">Library</span><span class="se">\\</span><span class="s">lib&#39;</span><span class="p">]</span>
    <span class="n">define_macros</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;SCIPY_MKL_H&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;HAVE_CBLAS&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)]</span>
    <span class="n">include_dirs</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;C:</span><span class="se">\\</span><span class="s">Program Files (x86)</span><span class="se">\\</span><span class="s">IntelSWTools</span><span class="se">\\</span><span class="s">compilers_and_libraries_2019.0.117</span><span class="se">\\</span><span class="s">windows</span><span class="se">\\</span><span class="s">mkl&#39;</span><span class="p">,</span> <span class="s">&#39;C:</span><span class="se">\\</span><span class="s">Program Files (x86)</span><span class="se">\\</span><span class="s">IntelSWTools</span><span class="se">\\</span><span class="s">compilers_and_libraries_2019.0.117</span><span class="se">\\</span><span class="s">windows</span><span class="se">\\</span><span class="s">mkl</span><span class="se">\\</span><span class="s">include&#39;</span><span class="p">,</span> <span class="s">&#39;C:</span><span class="se">\\</span><span class="s">Program Files (x86)</span><span class="se">\\</span><span class="s">IntelSWTools</span><span class="se">\\</span><span class="s">compilers_and_libraries_2019.0.117</span><span class="se">\\</span><span class="s">windows</span><span class="se">\\</span><span class="s">mkl</span><span class="se">\\</span><span class="s">lib&#39;</span><span class="p">,</span> <span class="s">&#39;D:/ProgramData/Anaconda3</span><span class="se">\\</span><span class="s">Library</span><span class="se">\\</span><span class="s">include&#39;</span><span class="p">]</span>      
    <span class="n">libraries</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;mkl_rt&#39;</span><span class="p">]</span>
    <span class="n">library_dirs</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;D:/ProgramData/Anaconda3</span><span class="se">\\</span><span class="s">Library</span><span class="se">\\</span><span class="s">lib&#39;</span><span class="p">]</span>
    <span class="n">define_macros</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;SCIPY_MKL_H&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;HAVE_CBLAS&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)]</span>
    <span class="n">include_dirs</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;C:</span><span class="se">\\</span><span class="s">Program Files (x86)</span><span class="se">\\</span><span class="s">IntelSWTools</span><span class="se">\\</span><span class="s">compilers_and_libraries_2019.0.117</span><span class="se">\\</span><span class="s">windows</span><span class="se">\\</span><span class="s">mkl&#39;</span><span class="p">,</span> <span class="s">&#39;C:</span><span class="se">\\</span><span class="s">Program Files (x86)</span><span class="se">\\</span><span class="s">IntelSWTools</span><span class="se">\\</span><span class="s">compilers_and_libraries_2019.0.117</span><span class="se">\\</span><span class="s">windows</span><span class="se">\\</span><span class="s">mkl</span><span class="se">\\</span><span class="s">include&#39;</span><span class="p">,</span> <span class="s">&#39;C:</span><span class="se">\\</span><span class="s">Program Files (x86)</span><span class="se">\\</span><span class="s">IntelSWTools</span><span class="se">\\</span><span class="s">compilers_and_libraries_2019.0.117</span><span class="se">\\</span><span class="s">windows</span><span class="se">\\</span><span class="s">mkl</span><span class="se">\\</span><span class="s">lib&#39;</span><span class="p">,</span> <span class="s">&#39;D:/ProgramData/Anaconda3</span><span class="se">\\</span><span class="s">Library</span><span class="se">\\</span><span class="s">include&#39;</span><span class="p">]</span>      
<span class="n">lapack_opt_info</span><span class="p">:</span>
    <span class="n">libraries</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;mkl_rt&#39;</span><span class="p">]</span>
    <span class="n">library_dirs</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;D:/ProgramData/Anaconda3</span><span class="se">\\</span><span class="s">Library</span><span class="se">\\</span><span class="s">lib&#39;</span><span class="p">]</span>
    <span class="n">define_macros</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;SCIPY_MKL_H&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;HAVE_CBLAS&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)]</span>
    <span class="n">include_dirs</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;C:</span><span class="se">\\</span><span class="s">Program Files (x86)</span><span class="se">\\</span><span class="s">IntelSWTools</span><span class="se">\\</span><span class="s">compilers_and_libraries_2019.0.117</span><span class="se">\\</span><span class="s">windows</span><span class="se">\\</span><span class="s">mkl&#39;</span><span class="p">,</span> <span class="s">&#39;C:</span><span class="se">\\</span><span class="s">Program Files (x86)</span><span class="se">\\</span><span class="s">IntelSWTools</span><span class="se">\\</span><span class="s">compilers_and_libraries_2019.0.117</span><span class="se">\\</span><span class="s">windows</span><span class="se">\\</span><span class="s">mkl</span><span class="se">\\</span><span class="s">include&#39;</span><span class="p">,</span> <span class="s">&#39;C:</span><span class="se">\\</span><span class="s">Program Files (x86)</span><span class="se">\\</span><span class="s">IntelSWTools</span><span class="se">\\</span><span class="s">compilers_and_libraries_2019.0.117</span><span class="se">\\</span><span class="s">windows</span><span class="se">\\</span><span class="s">mkl</span><span class="se">\\</span><span class="s">lib&#39;</span><span class="p">,</span> <span class="s">&#39;D:/ProgramData/Anaconda3</span><span class="se">\\</span><span class="s">Library</span><span class="se">\\</span><span class="s">include&#39;</span><span class="p">]</span> 
</pre></div>


<h1 id="2-pandas">2. 更高效的使用pandas</h1>
<h2 id="21-io">2.1. 高效数据IO</h2>
<h3 id="211-pandas">2.1.1. 使用pandas自带函数读取文件</h3>
<p>pandas是带buffer，按块读取的。python直接读取是按字节的。一般情况下使用pandas会比直接使用python快</p>
<h3 id="212-io">2.1.2. 使用二进制格式文件进行I/O</h3>
<p>选择合适的文件格式，有利于IO性能提升<sup id="fnref:best_format"><a class="footnote-ref" href="#fn:best_format" rel="footnote">5</a></sup></p>
<p>在极度追求IO性能的情况下推荐使用二进制文件格式（如：<code>hdf</code>、<code>feather</code>或<code>h5py</code>格式）。</p>
<div class="hlcode"><pre><span class="c"># Text csv</span>
<span class="n">df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">&quot;./test.csv&quot;</span><span class="p">)</span>
<span class="c"># 41.1 s</span>
<span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s">&quot;./test.csv&quot;</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c"># 4min 7s</span>
<span class="c"># 800MB -&gt; ./test.csv</span>
<span class="c"># 1.6GB -&gt; df</span>
</pre></div>


<h4 id="2121-hdf5-format">2.1.2.1. HDF5 Format</h4>
<p>HDF5 是一种高效的文件格式,<br />
I/O 读取需要依赖 PyTables &gt;= 3.0.0. </p>
<div class="hlcode"><pre><span class="c"># binary  HDF5 Format </span>
<span class="n">df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">read_hdf</span><span class="p">(</span><span class="s">&quot;./test.h5&quot;</span><span class="p">,</span><span class="n">key</span><span class="o">=</span><span class="s">&quot;df&quot;</span><span class="p">)</span>
<span class="c"># 6.39 s</span>
<span class="n">df</span><span class="o">.</span><span class="n">to_hdf</span><span class="p">(</span><span class="s">&quot;./test.h5&quot;</span><span class="p">,</span><span class="n">key</span><span class="o">=</span><span class="s">&quot;df&quot;</span><span class="p">,</span><span class="n">model</span><span class="o">=</span><span class="s">&quot;w&quot;</span><span class="p">)</span>
<span class="c"># 48.3 s</span>
<span class="c"># 1.6GB -&gt; ./test.h5</span>
<span class="c"># 1.6GB -&gt; df</span>
</pre></div>


<h4 id="2122-feather">2.1.2.2. feather</h4>
<p>Feather 的开发依赖于 Apache Arrow 计划，是一种快速、互动的文件存储格式 <br />
注意：<br />
- pd.read_feather 默认 <code>nthreads=1</code>，可以调整</p>
<div class="hlcode"><pre><span class="c"># feather</span>
<span class="n">df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">read_feather</span><span class="p">(</span><span class="s">&quot;./test.feather&quot;</span><span class="p">,</span><span class="n">nthreads</span> <span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c"># 21.9 s</span>
<span class="n">df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">read_feather</span><span class="p">(</span><span class="s">&quot;./test.feather&quot;</span><span class="p">,</span><span class="n">nthreads</span> <span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="c"># 17s</span>
<span class="n">df</span><span class="o">.</span><span class="n">to_feather</span><span class="p">(</span><span class="s">&quot;./test.feather&quot;</span><span class="p">)</span>
<span class="c"># 8 s</span>
<span class="c"># 1.6GB -&gt; ./test.feather</span>
<span class="c"># 1.6GB -&gt; df</span>
</pre></div>


<h4 id="2123-parquet-">2.1.2.3. parquet--推荐</h4>
<p><a href="https://parquet.apache.org/">apache parquet</a> 为dataframe 格式的内存数据，IO处理提供了优秀的解决方案。<br />
<code>pd.read_parquet</code> 支持多引擎，兼顾持久化后的内存，支持多种文件路径<br />
<strong>注意</strong>：<br />
1. <strong>columns_name</strong> 不支持重复的列名和非字符串列名。<br />
2. <code>df.index.name=None or ""</code> index 指引如果有，必须是字符串</p>
<p>关于引擎的说明：<br />
1. <code>fastparquet</code> uses <strong>numba</strong>, <br />
2. <code>pyarrow</code> uses a <strong>c-library</strong>,不支持 datetime数据</p>
<p><img alt="" src="/attach/images/2020-03-09-08-12-42.png" /></p>
<div class="hlcode"><pre><span class="n">df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">(</span><span class="s">&#39;./test.parquet&#39;</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s">&#39;pyarrow&#39;</span><span class="p">)</span>
<span class="c"># 13.9 s</span>
<span class="n">df</span><span class="o">.</span><span class="n">to_parquet</span><span class="p">(</span><span class="s">&#39;./test.parquet&#39;</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s">&#39;pyarrow&#39;</span><span class="p">)</span>
<span class="c"># 12 s</span>
<span class="c"># 7.13 MB -&gt; ./test.parquet</span>
<span class="c"># 1.6GB -&gt; df</span>

<span class="c"># 推荐使用 pyarrow 引擎</span>
<span class="n">df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">(</span><span class="s">&#39;./test.parquet&#39;</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s">&#39;fastparquet&#39;</span><span class="p">)</span>

<span class="n">df</span><span class="o">.</span><span class="n">to_parquet</span><span class="p">(</span><span class="s">&#39;./test.parquet&#39;</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s">&#39;fastparquet&#39;</span><span class="p">,</span><span class="n">compression</span><span class="o">=</span><span class="s">&quot;UNCOMPRESSED&quot;</span><span class="p">)</span>
<span class="c"># 8.26 s</span>
<span class="c"># 1.6GB-&gt; ./test.parquet</span>
<span class="n">df</span><span class="o">.</span><span class="n">to_parquet</span><span class="p">(</span><span class="s">&#39;./test.parquet&#39;</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s">&#39;fastparquet&#39;</span><span class="p">,</span><span class="n">compression</span><span class="o">=</span><span class="s">&quot;GZIP&quot;</span><span class="p">)</span>
<span class="c"># 7.13 MB -&gt; ./test.parquet</span>
<span class="c"># 14.7s</span>
<span class="c"># 1.6GB -&gt; df</span>
</pre></div>


<h4 id="2124-python-pickle-format">2.1.2.4. Python Pickle Format</h4>
<p>直接使用</p>
<div class="hlcode"><pre><span class="c"># binary Python Pickle Format</span>
<span class="n">df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">read_pickle</span><span class="p">(</span><span class="s">&quot;./test.pkl&quot;</span><span class="p">)</span>
<span class="c"># 3.46 s</span>
<span class="n">df</span><span class="o">.</span><span class="n">to_pickle</span><span class="p">(</span><span class="s">&quot;./test.pkl&quot;</span><span class="p">)</span>
<span class="c"># 35.7 s</span>
<span class="c"># 1.6GB -&gt; ./test.pkl</span>
<span class="c"># 1.6GB -&gt; df</span>
</pre></div>


<p>一般情况下HDF的读取比读取csv文件快几十倍，但HDF文件在大小上会稍微大一些。</p>
<h4 id="_1">比较</h4>
<div class="hlcode"><pre><span class="n">print</span><span class="p">(</span><span class="s">&quot;pandas df to disk ####################################################&quot;</span><span class="p">)</span>
<span class="n">print</span><span class="p">(</span><span class="err">&#39;</span><span class="n">example_feather</span><span class="o">:</span><span class="err">&#39;</span><span class="p">)</span>
<span class="o">%</span><span class="n">timeit</span> <span class="n">feather</span><span class="p">.</span><span class="n">write_feather</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="err">&#39;</span><span class="n">example_feather</span><span class="err">&#39;</span><span class="p">)</span>
<span class="cp"># 2.62 ms ± 35.8 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</span>
<span class="n">print</span><span class="p">(</span><span class="err">&#39;</span><span class="n">example_parquet</span><span class="o">:</span><span class="err">&#39;</span><span class="p">)</span>
<span class="o">%</span><span class="n">timeit</span> <span class="n">pq</span><span class="p">.</span><span class="n">write_table</span><span class="p">(</span><span class="n">pa</span><span class="p">.</span><span class="n">Table</span><span class="p">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">df</span><span class="p">),</span> <span class="err">&#39;</span><span class="n">example</span><span class="p">.</span><span class="n">parquet</span><span class="err">&#39;</span><span class="p">)</span>
<span class="cp"># 3.19 ms ± 51 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</span>
<span class="n">print</span><span class="p">()</span>

<span class="n">print</span><span class="p">(</span><span class="s">&quot;for comparison:&quot;</span><span class="p">)</span>
<span class="n">print</span><span class="p">(</span><span class="err">&#39;</span><span class="n">example_pickle</span><span class="o">:</span><span class="err">&#39;</span><span class="p">)</span>
<span class="o">%</span><span class="n">timeit</span> <span class="n">df</span><span class="p">.</span><span class="n">to_pickle</span><span class="p">(</span><span class="err">&#39;</span><span class="n">example_pickle</span><span class="err">&#39;</span><span class="p">)</span>
<span class="cp"># 2.75 ms ± 18.8 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</span>
<span class="n">print</span><span class="p">(</span><span class="err">&#39;</span><span class="n">example_fp_parquet</span><span class="o">:</span><span class="err">&#39;</span><span class="p">)</span>
<span class="o">%</span><span class="n">timeit</span> <span class="n">fp</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="err">&#39;</span><span class="n">example_fp_parquet</span><span class="err">&#39;</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
<span class="cp"># 7.06 ms ± 205 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)</span>
<span class="n">print</span><span class="p">(</span><span class="err">&#39;</span><span class="n">example_hdf</span><span class="o">:</span><span class="err">&#39;</span><span class="p">)</span>
<span class="o">%</span><span class="n">timeit</span> <span class="n">df</span><span class="p">.</span><span class="n">to_hdf</span><span class="p">(</span><span class="err">&#39;</span><span class="n">example_hdf</span><span class="err">&#39;</span><span class="p">,</span> <span class="err">&#39;</span><span class="n">key_to_store</span><span class="err">&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="sc">&#39;w&#39;</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="n">True</span><span class="p">)</span>
<span class="cp"># 24.6 ms ± 4.45 ms per loop (mean ± std. dev. of 7 runs, 100 loops each)</span>
<span class="n">print</span><span class="p">()</span>

<span class="n">print</span><span class="p">(</span><span class="s">&quot;pandas df from disk ##################################################&quot;</span><span class="p">)</span>
<span class="n">print</span><span class="p">(</span><span class="err">&#39;</span><span class="n">example_feather</span><span class="o">:</span><span class="err">&#39;</span><span class="p">)</span>
<span class="o">%</span><span class="n">timeit</span> <span class="n">feather</span><span class="p">.</span><span class="n">read_feather</span><span class="p">(</span><span class="err">&#39;</span><span class="n">example_feather</span><span class="err">&#39;</span><span class="p">)</span>
<span class="cp"># 969 µs ± 1.8 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</span>
<span class="n">print</span><span class="p">(</span><span class="err">&#39;</span><span class="n">example_parquet</span><span class="o">:</span><span class="err">&#39;</span><span class="p">)</span>
<span class="o">%</span><span class="n">timeit</span> <span class="n">pq</span><span class="p">.</span><span class="n">read_table</span><span class="p">(</span><span class="err">&#39;</span><span class="n">example</span><span class="p">.</span><span class="n">parquet</span><span class="err">&#39;</span><span class="p">).</span><span class="n">to_pandas</span><span class="p">()</span>
<span class="cp"># 1.9 ms ± 5.5 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</span>

<span class="n">print</span><span class="p">(</span><span class="s">&quot;for comparison:&quot;</span><span class="p">)</span>
<span class="n">print</span><span class="p">(</span><span class="err">&#39;</span><span class="n">example_pickle</span><span class="o">:</span><span class="err">&#39;</span><span class="p">)</span>
<span class="o">%</span><span class="n">timeit</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_pickle</span><span class="p">(</span><span class="err">&#39;</span><span class="n">example_pickle</span><span class="err">&#39;</span><span class="p">)</span>
<span class="cp"># 1.07 ms ± 6.21 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</span>
<span class="n">print</span><span class="p">(</span><span class="err">&#39;</span><span class="n">example_fp_parquet</span><span class="o">:</span><span class="err">&#39;</span><span class="p">)</span>
<span class="o">%</span><span class="n">timeit</span> <span class="n">fp</span><span class="p">.</span><span class="n">ParquetFile</span><span class="p">(</span><span class="err">&#39;</span><span class="n">example_fp_parquet</span><span class="err">&#39;</span><span class="p">).</span><span class="n">to_pandas</span><span class="p">()</span>
<span class="cp"># 4.53 ms ± 260 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)</span>
<span class="n">print</span><span class="p">(</span><span class="err">&#39;</span><span class="n">example_hdf</span><span class="o">:</span><span class="err">&#39;</span><span class="p">)</span>
<span class="o">%</span><span class="n">timeit</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_hdf</span><span class="p">(</span><span class="err">&#39;</span><span class="n">example_hdf</span><span class="err">&#39;</span><span class="p">)</span>
<span class="cp"># 10 ms ± 43.4 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</span>

<span class="cp"># pandas version: 0.22.0</span>
<span class="cp"># fastparquet version: 0.1.3</span>
<span class="cp"># numpy version: 1.13.3</span>
<span class="cp"># pandas version: 0.22.0</span>
<span class="cp"># pyarrow version: 0.8.0</span>
<span class="cp"># sys.version: 3.6.3</span>
<span class="cp"># example Dataframe taken from https:</span><span class="c1">//arrow.apache.org/docs/python/parquet.html</span>
</pre></div>


<h3 id="213">2.1.3. 数据压缩后再进行持久化</h3>
<div class="hlcode"><pre><span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s">&#39;output.csv.gz&#39;</span>
         <span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">&#39;|&#39;</span>
         <span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">True</span>
         <span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">False</span>
         <span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">100000</span>
         <span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="s">&#39;gzip&#39;</span>
         <span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s">&#39;utf-8&#39;</span><span class="p">)</span>

<span class="c"># 使用compression=&#39;gzip&#39; 压缩文件 </span>

<span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s">&quot;./test.csv&quot;</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c"># 4min 7s</span>
<span class="c"># 800MB -&gt; ./test.csv</span>
<span class="c"># 1.6GB -&gt; df</span>

<span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s">&quot;./test.csv.gz&quot;</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="s">&#39;gzip&#39;</span><span class="p">,</span><span class="n">encoding</span><span class="o">=</span><span class="s">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="c"># 5min</span>
<span class="c"># 9.80MB -&gt; ./test.csv.gz</span>
<span class="c"># 1.6GB -&gt; df</span>


<span class="n">df</span><span class="o">.</span><span class="n">to_pickle</span><span class="p">(</span><span class="s">&quot;data.pkl.compress&quot;</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="s">&quot;gzip&quot;</span><span class="p">)</span>

<span class="n">rt</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_pickle</span><span class="p">(</span><span class="s">&quot;data.pkl.compress&quot;</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="s">&quot;gzip&quot;</span><span class="p">)</span>
</pre></div>


<h2 id="22-">2.2. 高效遍历数据--避免常规循环</h2>
<p>总结： 如果必须要使用循环，建议使用 apply； 否则的话尽量适应向量化的方法</p>
<h3 id="221-x1">2.2.1. 标准遍历--x1</h3>
<div class="hlcode"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)):</span>
    <span class="err">判定</span><span class="mi">1</span><span class="err">：</span>
        <span class="n">df</span><span class="p">[</span><span class="s">&quot;列名&quot;</span><span class="p">]</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">value</span>
    <span class="err">判定</span><span class="mi">2</span><span class="err">：</span>
        <span class="n">df</span><span class="p">[</span><span class="s">&quot;列名&quot;</span><span class="p">]</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">value</span>
</pre></div>


<div class="hlcode"><pre><span class="k">def</span> <span class="nf">soc_loop</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">TEAM</span><span class="p">,):</span>
    <span class="n">df</span><span class="p">[</span><span class="s">&#39;Draws&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">99999</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)):</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">df</span><span class="p">[</span><span class="s">&#39;HomeTeam&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">==</span> <span class="n">TEAM</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s">&#39;FTR&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;D&#39;</span><span class="p">))</span> <span class="o">|</span> \
            <span class="p">((</span><span class="n">df</span><span class="p">[</span><span class="s">&#39;AwayTeam&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">==</span> <span class="n">TEAM</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s">&#39;FTR&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;D&#39;</span><span class="p">)):</span>
            <span class="n">df</span><span class="p">[</span><span class="s">&#39;Draws&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;Draw&#39;</span>
        <span class="k">elif</span> <span class="p">((</span><span class="n">df</span><span class="p">[</span><span class="s">&#39;HomeTeam&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">==</span> <span class="n">TEAM</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s">&#39;FTR&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;D&#39;</span><span class="p">))</span> <span class="o">|</span> \
            <span class="p">((</span><span class="n">df</span><span class="p">[</span><span class="s">&#39;AwayTeam&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">==</span> <span class="n">TEAM</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s">&#39;FTR&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;D&#39;</span><span class="p">)):</span>
            <span class="n">df</span><span class="p">[</span><span class="s">&#39;Draws&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;No_Draw&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s">&#39;Draws&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;No_Game&#39;</span>
    <span class="k">return</span> <span class="n">df</span> 

<span class="n">df</span><span class="o">=</span><span class="n">soc_loop</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="s">&quot;Arsenal&quot;</span><span class="p">)</span>
</pre></div>


<h3 id="222-iterrows-x321">2.2.2. 使用内置函数 iterrows()--x321倍加速</h3>
<ol>
<li>使用的是python level 的loop </li>
<li>实现形式是通过为新的df列添加 list来实现的，其中list通过 <code>append</code> 遍历来实现</li>
</ol>
<div class="hlcode"><pre><span class="n">add_list</span><span class="o">=</span><span class="p">[]</span>
<span class="k">for</span> <span class="n">index</span><span class="p">,</span><span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
    <span class="n">add_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">parmaters_1</span><span class="p">,</span><span class="n">row</span><span class="p">[</span><span class="s">&quot;选择相关列名1&quot;</span><span class="p">],</span><span class="n">row</span><span class="p">[</span><span class="s">&quot;选择相关列名2&quot;</span><span class="p">]))</span>

<span class="n">df</span><span class="p">[</span><span class="s">&quot;列名&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">add_list</span>
</pre></div>


<h3 id="223-apply-x811">2.2.3. 使用内置函数 apply()--x811倍加速</h3>
<p><code>apply()</code>方法可将函数应用于dataframe特定<code>行</code>或<code>列</code>。 <strong>其本质是另一种形式的遍历loop</strong>。 但比python-level 的遍历效率更高。</p>
<p>函数可以由lambda方式在代码中内嵌实现，lambda函数的末尾包含axis参数，用来告知Pandas将函数运用于行（axis = 1）或者列（axis = 0），可以普通自定义函数设置。</p>
<div class="hlcode"><pre><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">row</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">sth</span> 
<span class="n">df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">foo</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s">&quot;A&quot;</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c">#输入pd.Series 到函数中，效率低</span>

<span class="n">df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">foo</span><span class="p">(</span><span class="o">*</span><span class="n">row</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c"># raw=True 输入numpy.array 到函数中，效率高 X10</span>



<span class="c"># 对一行进行操作，作用于列</span>
<span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="err">选择行</span><span class="p">,:]</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">col</span><span class="p">:</span> <span class="n">col</span><span class="p">[</span><span class="s">&quot;index_1&quot;</span><span class="p">]</span><span class="o">+</span><span class="n">col</span><span class="p">[</span><span class="s">&quot;index_2&quot;</span><span class="p">],</span> <span class="n">axis</span> <span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c"># 对一列进行操作，作用于行</span>
<span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="err">选择列</span><span class="p">]</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="s">&quot;选择相关列名1&quot;</span><span class="p">]</span><span class="o">+</span><span class="n">row</span><span class="p">[</span><span class="s">&quot;选择相关列名2&quot;</span><span class="p">],</span> <span class="n">axis</span> <span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>


<h3 id="224-groupby-">2.2.4. 使用groupby()--减少遍历元素</h3>
<p>通过使用<code>groupby()</code>将数据元素合并分组，避免重复元素遍历，可以提高程序运行效率。</p>
<p><img alt="" src="/attach/images/2020-03-13-20-41-22.png" /></p>
<p>主要有：<br />
1. grouped.apply(func)<br />
2. grouped.agg(func)<br />
3. grouped.transform(func)<br />
4. grouped.uni_func() # 内置函数uni_func</p>
<p>上述4种应用本质上还是<code>python-level</code>的loop，只是针对dataframe这类的数据结构有不同程度的优化，包括底层C/C++的编译优化</p>
<h4 id="2241-groupbyapplyfunc">2.2.4.1. groupby().apply(func)</h4>
<p>自定义函数func<br />
<strong>输入：</strong>  apply 默认传入的是<strong>整个dataframe</strong> 到<code>自定义函数func</code><br />
<strong>原理：</strong> apply 函数将<code>函数func</code> 应用到您指定的每个group。<br />
<strong>输出：</strong> apply 是一个更一般化的方法，自定义函数可以返回scalar, Series , DataFrame ,numpy array , list等形式</p>
<div class="hlcode"><pre><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s">&#39;Q&#39;</span><span class="p">:[</span><span class="s">&#39;LI&#39;</span><span class="p">,</span><span class="s">&#39;ZHANG&#39;</span><span class="p">,</span><span class="s">&#39;ZHANG&#39;</span><span class="p">,</span><span class="s">&#39;LI&#39;</span><span class="p">,</span><span class="s">&#39;WANG&#39;</span><span class="p">],</span> <span class="s">&#39;A&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="s">&#39;B&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="s">&#39;C&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]})</span>
<span class="o">&gt;&gt;&gt;</span>
    <span class="n">Q</span>   <span class="n">A</span>   <span class="n">B</span>   <span class="n">C</span>   
<span class="mi">0</span>   <span class="n">LI</span>  <span class="mi">1</span>   <span class="mi">1</span>   <span class="mi">3</span>   
<span class="mi">1</span>   <span class="n">ZHANG</span>   <span class="mi">1</span>   <span class="o">-</span><span class="mi">1</span>  <span class="mi">4</span>   
<span class="mi">2</span>   <span class="n">ZHANG</span>   <span class="mi">1</span>   <span class="mi">0</span>   <span class="mi">5</span>   
<span class="mi">3</span>   <span class="n">LI</span>  <span class="mi">2</span>   <span class="mi">1</span>   <span class="mi">6</span>   
<span class="mi">4</span>   <span class="n">WANG</span>    <span class="mi">2</span>   <span class="mi">2</span>   <span class="mi">7</span>   

<span class="c"># 最好先对df 进行切片</span>
<span class="n">a</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,[</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="s">&quot;C&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="s">&quot;A&quot;</span><span class="p">]</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="s">&quot;C&quot;</span><span class="p">])</span>
<span class="c"># a 是 pd.Series</span>
<span class="c"># x 是apply 输入到自定义函数func函数中的变量，是dataframe格式</span>
<span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">df</span><span class="p">[</span><span class="s">&quot;d&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">a</span>
<span class="o">&gt;&gt;&gt;</span>
    <span class="n">Q</span>   <span class="n">A</span>   <span class="n">B</span>   <span class="n">C</span>   <span class="n">d</span>
<span class="mi">0</span>   <span class="n">LI</span>  <span class="mi">1</span>   <span class="mi">1</span>   <span class="mi">3</span>   <span class="mi">4</span>
<span class="mi">1</span>   <span class="n">ZHANG</span>   <span class="mi">1</span>   <span class="o">-</span><span class="mi">1</span>  <span class="mi">4</span>   <span class="mi">5</span>
<span class="mi">2</span>   <span class="n">ZHANG</span>   <span class="mi">1</span>   <span class="mi">0</span>   <span class="mi">5</span>   <span class="mi">6</span>
<span class="mi">3</span>   <span class="n">LI</span>  <span class="mi">2</span>   <span class="mi">1</span>   <span class="mi">6</span>   <span class="mi">8</span>
<span class="mi">4</span>   <span class="n">WANG</span>    <span class="mi">2</span>   <span class="mi">2</span>   <span class="mi">7</span>   <span class="mi">9</span>

<span class="c">###其他事项</span>
<span class="k">def</span> <span class="nf">subtract_two</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="s">&#39;B&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="s">&#39;C&#39;</span><span class="p">]</span>
<span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">subtract_two</span><span class="p">)</span>
<span class="c"># 可以正常运行</span>
<span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">subtract_two</span><span class="p">)</span>
<span class="c"># 报错</span>
</pre></div>


<h4 id="2242-groupbyaggfunc">2.2.4.2. groupby().agg(func)</h4>
<p><strong>输入</strong>：agg的调用需要要指定字段,输入指定列到函数func</p>
<p><strong>输出</strong>：Dataframe ，groupby index</p>
<div class="hlcode"><pre><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s">&quot;Q&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">([</span><span class="s">&quot;mean&quot;</span><span class="p">,</span><span class="s">&quot;sum&quot;</span><span class="p">])</span>
    <span class="n">A</span>       <span class="n">B</span>       <span class="n">C</span>
    <span class="n">mean</span>    <span class="nb">sum</span> <span class="n">mean</span>    <span class="nb">sum</span> <span class="n">mean</span>    <span class="nb">sum</span>
<span class="n">Q</span>                       
<span class="n">LI</span>  <span class="mf">1.5</span> <span class="mi">3</span>   <span class="mf">1.0</span> <span class="mi">2</span>   <span class="mf">4.5</span> <span class="mi">9</span>
<span class="n">WANG</span>    <span class="mf">2.0</span> <span class="mi">2</span>   <span class="mf">2.0</span> <span class="mi">2</span>   <span class="mf">7.0</span> <span class="mi">7</span>
<span class="n">ZHANG</span>   <span class="mf">1.0</span> <span class="mi">2</span>   <span class="o">-</span><span class="mf">0.5</span>    <span class="o">-</span><span class="mi">1</span>  <span class="mf">4.5</span> <span class="mi">9</span>


<span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">B</span><span class="o">=</span><span class="s">&#39;sum&#39;</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;mean&#39;</span><span class="p">,</span> <span class="s">&#39;prod&#39;</span><span class="p">]))</span>
<span class="o">&gt;&gt;&gt;</span>
    <span class="n">B</span>   <span class="n">C</span>
    <span class="nb">sum</span> <span class="n">mean</span>    <span class="n">prod</span>
<span class="n">A</span>           
<span class="mi">1</span>   <span class="mi">0</span>   <span class="mf">4.0</span> <span class="mi">60</span>
<span class="mi">2</span>   <span class="mi">3</span>   <span class="mf">6.5</span> <span class="mi">42</span>
</pre></div>


<h4 id="2243-groupbytransformfunc">2.2.4.3. groupby().transform(func)</h4>
<p>自定义函数func<br />
<strong>输入</strong>：以Series 形式输入<br />
<strong>返回</strong>：自定义函数<code>func</code> 必须返回<strong>行数相同（必须与group长度相同）</strong>的一维序列（sequence，one dimensional Series, array or list,or scale），或者标量（a single scalar object ）</p>
<div class="hlcode"><pre><span class="c"># sequence -&gt; same row </span>
<span class="k">def</span> <span class="nf">rand_group_len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="n">new_df</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s">&#39;Q&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">rand_group_len</span><span class="p">)</span>

<span class="n">new_df</span>
<span class="o">&gt;&gt;&gt;</span>
    <span class="n">A</span>   <span class="n">B</span>   <span class="n">C</span>
<span class="mi">0</span>   <span class="mf">0.255113</span>    <span class="mf">0.894918</span>    <span class="mf">0.518019</span>
<span class="mi">1</span>   <span class="mf">0.641294</span>    <span class="mf">0.849864</span>    <span class="mf">0.847467</span>
<span class="mi">2</span>   <span class="mf">0.815746</span>    <span class="mf">0.224903</span>    <span class="mf">0.732254</span>
<span class="mi">3</span>   <span class="mf">0.575618</span>    <span class="mf">0.007238</span>    <span class="mf">0.621828</span>
<span class="mi">4</span>   <span class="mf">0.254013</span>    <span class="mf">0.331561</span>    <span class="mf">0.431511</span>

<span class="c"># scalar</span>
<span class="k">def</span> <span class="nf">group_sum</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="n">sequence</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">group_sum</span><span class="p">)</span>


<span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="mi">0</span>    <span class="mi">0</span>
<span class="mi">1</span>    <span class="mi">1</span>
<span class="mi">2</span>    <span class="mi">2</span>
<span class="n">s</span><span class="o">.</span><span class="n">transform</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span>
       <span class="n">sqrt</span>        <span class="n">exp</span>
<span class="mi">0</span>  <span class="mf">0.000000</span>   <span class="mf">1.000000</span>
<span class="mi">1</span>  <span class="mf">1.000000</span>   <span class="mf">2.718282</span>
<span class="mi">2</span>  <span class="mf">1.414214</span>   <span class="mf">7.389056</span>
</pre></div>


<h4 id="2244-groupby">2.2.4.4. groupby().内置函数</h4>
<p>groupyby 可以直接用的优化过的高速运算方法有count()、sum()、prod()、mean()、median()、min()、max()、std()、var()、first()、last()。</p>
<div class="hlcode"><pre><span class="n">grouop_df</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="c"># grouop_df index 是A</span>
</pre></div>


<p>在<code>groupby().agg</code>和<code>groupby().transform</code>时尽量使用内置函数计算，可加速计算。</p>
<div class="hlcode"><pre><span class="n">grouop_df</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="s">&quot;mean&quot;</span><span class="p">)</span>
<span class="c"># grouop_df index 是range(0,n)</span>

<span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">([</span><span class="s">&#39;mean&#39;</span><span class="p">,</span> <span class="s">&#39;std&#39;</span><span class="p">])</span>
</pre></div>


<h3 id="225-groupbyapplynumpy">2.2.5. 更快的groupby.apply()方法，使用numpy 自定义</h3>
<p>参考<sup id="fnref:fast_groupby"><a class="footnote-ref" href="#fn:fast_groupby" rel="footnote">4</a></sup> : Fast groupby-apply operations in Python with and without Pandas<br />
http://esantorella.com/2016/06/16/groupby/</p>
<div class="hlcode"><pre><span class="n">first_category</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">n_categories</span><span class="p">,</span> <span class="n">n_obs</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_obs</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s">&#39;first category&#39;</span><span class="p">:</span> <span class="n">first_category</span><span class="p">,</span>
                   <span class="s">&#39;y&#39;</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>

<span class="k">class</span> <span class="nc">Groupby</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        精华就再在这里 np.unique</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys_as_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">return_inverse</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_keys</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys_as_int</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_indices</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">set_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_keys</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys_as_int</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">vector</span><span class="p">,</span> <span class="n">broadcast</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">broadcast</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vector</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">vector</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_keys</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">):</span>
                <span class="n">result</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">keys_as_int</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">vector</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">result</span>

<span class="o">%%</span><span class="n">timeit</span>
<span class="n">grouped</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s">&#39;first category&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span>
<span class="c"># 595 ms ± 162 ms</span>

<span class="n">a</span><span class="o">=</span><span class="n">Groupby</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s">&quot;first category&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="s">&quot;y&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span><span class="bp">False</span><span class="p">)</span>
<span class="c"># 36.7 ms ± 6.65 ms</span>

<span class="o">%%</span><span class="n">timeit</span>
<span class="n">df</span><span class="p">[</span><span class="s">&#39;mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s">&#39;first category&#39;</span><span class="p">)[</span><span class="s">&#39;y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span>
<span class="c">#4.28 ms ± 1.03 ms</span>
<span class="c"># 还是transform好</span>
</pre></div>


<div class="hlcode"><pre><span class="c"># 充分利用这一性能对dataframe 进行分解 然后进行高效map运算</span>
<span class="n">unique_keys</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">],</span> <span class="n">return_inverse</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">unique_keys</span><span class="p">)</span> 
<span class="o">&gt;&gt;&gt;</span>
<span class="n">array</span><span class="p">([{</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">}],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> 
<span class="o">&gt;&gt;&gt;</span>
<span class="c">#list </span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="n">unique_keys</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span> 
<span class="o">&gt;&gt;&gt;</span>
<span class="n">array</span><span class="p">([</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;&lt;U1&#39;</span><span class="p">)</span>
</pre></div>


<h3 id="226-npvectorizeapply">2.2.6. 使用向量化函数 np.vectorize代替apply 处理</h3>
<p><code>np.vectorize</code> is <strong>fake vectorize</strong>.<sup id="fnref:fake_vectorize"><a class="footnote-ref" href="#fn:fake_vectorize" rel="footnote">3</a></sup></p>
<p><code>np.vectorize</code>的主要作用原理是使用<strong>python-level</strong> 的map函数封装<code>pyfunc</code>对输入数组求值，而不是numpy的boardcast 规则。在这里<strong>boardcast 规则并不重要</strong>。</p>
<p><code>np.vectorize</code> 运行过程中通过使用<code>np.frompyfunc</code>方法将<code>pyfunc</code> 转换为 numpy 的通用函数<code>ufunc</code>，并通过一些优化（例如缓存）以实现性能提升。</p>
<p>np.vectorize 依然属于 Python-level 的loop，虽然它比<code>pd.DataFrame.apply</code>更加高效。但依据其原理，其作用效果于 <code>map</code>,<code>zip</code> 在同一级别上</p>
<div class="hlcode"><pre><span class="o">%</span><span class="n">timeit</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">divide</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="s">&#39;B&#39;</span><span class="p">]))</span>                                   <span class="c"># 43.9 ms</span>
<span class="o">%</span><span class="n">timeit</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">divide</span><span class="p">)(</span><span class="n">df</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="s">&#39;B&#39;</span><span class="p">])</span>                                <span class="c"># 48.1 ms</span>
<span class="o">%</span><span class="n">timeit</span> <span class="p">[</span><span class="n">divide</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="s">&#39;B&#39;</span><span class="p">])]</span>                      <span class="c"># 49.4 ms</span>
<span class="o">%</span><span class="n">timeit</span> <span class="n">df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">divide</span><span class="p">(</span><span class="o">*</span><span class="n">row</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>                  <span class="c"># 760 ms</span>
</pre></div>


<div class="hlcode"><pre><span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span>
<span class="n">vecfunc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
<span class="n">new_array</span> <span class="o">=</span> <span class="n">vecfunc</span><span class="p">(</span><span class="n">old_array</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span>
<span class="n">df</span><span class="p">[</span><span class="s">&#39;result2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">foo</span><span class="p">)(</span><span class="n">df</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="s">&#39;B&#39;</span><span class="p">])</span>

<span class="c"># func:A python function or method</span>
<span class="nb">type</span><span class="p">(</span><span class="n">vecfunc</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="n">numpy</span><span class="o">.</span><span class="n">vectorize</span>
<span class="c"># Vectorized function. 向量化的函数</span>

<span class="nb">type</span><span class="p">(</span><span class="n">new_array</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="n">numpy</span><span class="o">.</span><span class="n">array</span>
</pre></div>


<h3 id="227-pandas-x9280">2.2.7. 使用pandas 向量化 —-x9280倍加速</h3>
<p>pandas 向量化：<br />
1. 避免使用python解释器 级别的loop循环 <br />
2. 使用优化的C编译器，使用内存更加高效<br />
3. 依据<strong>有条件的切片</strong><code>df.loc[i,c]</code> 及函数实现（<strong>注意实现方式</strong>） </p>
<div class="hlcode"><pre><span class="o">%</span><span class="n">timeit</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">df</span><span class="p">[</span><span class="s">&#39;B&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">replace</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>  <span class="c"># 1.96 ms</span>
</pre></div>


<div class="hlcode"><pre><span class="c"># 构建函数</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">parameter_1</span><span class="p">,</span><span class="n">col_1</span><span class="p">,</span><span class="n">col_2</span><span class="p">,</span><span class="o">..</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    col_1: df array 相同df</span>
<span class="sd">    col_2: df array 相同df</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span><span class="p">[</span><span class="s">&quot;列名&quot;</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="err">行条件</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;列名&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">value_1</span>
    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="err">行条件</span><span class="mi">2</span><span class="p">(</span><span class="n">col_1</span><span class="o">==</span><span class="err">值</span><span class="mi">1</span><span class="p">,</span><span class="n">col_2</span><span class="o">==</span><span class="err">值</span><span class="mi">2</span><span class="p">),</span><span class="s">&quot;列名&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">value_2</span>

<span class="n">df</span><span class="p">[</span><span class="s">&quot;列名&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">func</span><span class="p">(</span><span class="n">parameter_1</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="s">&quot;选择列名1&quot;</span><span class="p">],</span><span class="n">df</span><span class="p">[</span><span class="s">&quot;选择列名2&quot;</span><span class="p">],</span><span class="o">..</span><span class="p">)</span>
</pre></div>


<div class="hlcode"><pre><span class="k">def</span> <span class="nf">soc_iter</span><span class="p">(</span><span class="n">TEAM</span><span class="p">,</span><span class="n">home</span><span class="p">,</span><span class="n">away</span><span class="p">,</span><span class="n">ftr</span><span class="p">):</span>
    <span class="n">df</span><span class="p">[</span><span class="s">&#39;Draws&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;No_Game&#39;</span>
    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[((</span><span class="n">home</span> <span class="o">==</span> <span class="n">TEAM</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ftr</span> <span class="o">==</span> <span class="s">&#39;D&#39;</span><span class="p">))</span> <span class="o">|</span> <span class="p">((</span><span class="n">away</span> <span class="o">==</span> <span class="n">TEAM</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ftr</span> <span class="o">==</span> <span class="s">&#39;D&#39;</span><span class="p">)),</span> <span class="s">&#39;Draws&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;Draw&#39;</span>
    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[((</span><span class="n">home</span> <span class="o">==</span> <span class="n">TEAM</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ftr</span> <span class="o">!=</span> <span class="s">&#39;D&#39;</span><span class="p">))</span> <span class="o">|</span> <span class="p">((</span><span class="n">away</span> <span class="o">==</span> <span class="n">TEAM</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ftr</span> <span class="o">!=</span> <span class="s">&#39;D&#39;</span><span class="p">)),</span> <span class="s">&#39;Draws&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;No_Draw&#39;</span>

<span class="n">df</span><span class="p">[</span><span class="s">&quot;Draws&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">soc_loop</span><span class="p">(</span><span class="s">&quot;Arsenal&quot;</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="s">&quot;HOME&quot;</span><span class="p">],</span><span class="n">df</span><span class="p">[</span><span class="s">&quot;AWAY&quot;</span><span class="p">],</span><span class="n">df</span><span class="p">[</span><span class="s">&quot;FTR&quot;</span><span class="p">])</span>
</pre></div>


<h3 id="228-numpy-x658880">2.2.8. 使用numpy 向量化--x658880倍加速</h3>
<p>pandas 向量化：<br />
1. 避免使用python解释器 级别的loop循环 <br />
2. 使用优化的C编译器，使用内存更加高效<br />
3. 条件切片<code>df.loc[i,c]</code> 及函数实现（<strong>注意实现方式</strong>） <br />
4. 函数输入的是numpy array (<strong>不同点</strong>)</p>
<div class="hlcode"><pre><span class="o">%</span><span class="n">timeit</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s">&#39;B&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">df</span><span class="p">[</span><span class="s">&#39;B&#39;</span><span class="p">])</span>       <span class="c"># 1.17 ms</span>

<span class="c"># 构建函数</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">parameter_1</span><span class="p">,</span><span class="n">col_1</span><span class="p">,</span><span class="n">col_2</span><span class="p">,</span><span class="o">..</span><span class="p">):</span>
    <span class="n">df</span><span class="p">[</span><span class="s">&quot;列名&quot;</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="err">行条件</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;列名&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">value_1</span>
    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="err">行条件</span><span class="mi">2</span><span class="p">(</span><span class="n">col_1</span><span class="o">==</span><span class="err">值</span><span class="mi">1</span><span class="p">,</span><span class="n">col_2</span><span class="o">==</span><span class="err">值</span><span class="mi">2</span><span class="p">),</span><span class="s">&quot;列名&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">value_2</span>

<span class="c"># 注意是 df[&quot;col&quot;].value</span>
<span class="n">df</span><span class="p">[</span><span class="s">&quot;列名&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">func</span><span class="p">(</span><span class="n">parameter_1</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="s">&quot;选择列名1&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="s">&quot;选择列名2&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="o">..</span><span class="p">)</span>
</pre></div>


<div class="hlcode"><pre><span class="k">def</span> <span class="nf">soc_iter</span><span class="p">(</span><span class="n">TEAM</span><span class="p">,</span><span class="n">home</span><span class="p">,</span><span class="n">away</span><span class="p">,</span><span class="n">ftr</span><span class="p">):</span>
    <span class="n">df</span><span class="p">[</span><span class="s">&#39;Draws&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;No_Game&#39;</span>
    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[((</span><span class="n">home</span> <span class="o">==</span> <span class="n">TEAM</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ftr</span> <span class="o">==</span> <span class="s">&#39;D&#39;</span><span class="p">))</span> <span class="o">|</span> <span class="p">((</span><span class="n">away</span> <span class="o">==</span> <span class="n">TEAM</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ftr</span> <span class="o">==</span> <span class="s">&#39;D&#39;</span><span class="p">)),</span> <span class="s">&#39;Draws&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;Draw&#39;</span>
    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[((</span><span class="n">home</span> <span class="o">==</span> <span class="n">TEAM</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ftr</span> <span class="o">!=</span> <span class="s">&#39;D&#39;</span><span class="p">))</span> <span class="o">|</span> <span class="p">((</span><span class="n">away</span> <span class="o">==</span> <span class="n">TEAM</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ftr</span> <span class="o">!=</span> <span class="s">&#39;D&#39;</span><span class="p">)),</span> <span class="s">&#39;Draws&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;No_Draw&#39;</span>

<span class="n">df</span><span class="p">[</span><span class="s">&quot;Draws&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">soc_loop</span><span class="p">(</span><span class="s">&quot;Arsenal&quot;</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="s">&quot;HOME&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="s">&quot;AWAY&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="s">&quot;FTR&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
</pre></div>


<h3 id="229">2.2.9. 总结</h3>
<p>总结： 如果必须要使用循环，建议使用 apply,同时考虑<strong>减少遍历元素数量</strong>和<strong>提前切片</strong>减小数据大小； 否则的话尽量适应向量化的方法</p>
<h2 id="23">2.3. 高效数据拼接</h2>
<h3 id="231-append">2.3.1. 避免 append</h3>
<p>数据在行层面的<code>df.append</code>，减少数据合并过程中的遍历搜索，建议使用先使用：<br />
1. <code>list.append</code> 的方式添加到Dataframe中<br />
2. 创建已知大小的空Dataframe，通过高效索引更改</p>
<div class="hlcode"><pre><span class="c"># 第一种方式（运行时间最长——1分钟，内存占用一般）</span>
<span class="n">start1</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
<span class="n">res1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">df_list</span><span class="p">:</span>
     <span class="n">res1</span> <span class="o">=</span> <span class="n">res1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;append耗时：</span><span class="si">%s</span><span class="s">秒&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">start1</span><span class="p">))</span>

<span class="c"># %% 第二种方式（运行时间相对第一种少一些——46秒，但内存接近溢出）</span>
<span class="n">start2</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
<span class="n">dict_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">df_list</span><span class="p">]</span>
<span class="n">combine_dict</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">dic</span> <span class="ow">in</span> <span class="n">dict_list</span><span class="p">:</span>
     <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">dic</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>
     <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
         <span class="n">combine_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">dic</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dic</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
         <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">res2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">combine_dict</span><span class="p">,</span> <span class="s">&#39;index&#39;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;dict合并方式耗时：</span><span class="si">%s</span><span class="s">秒&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">start2</span><span class="p">))</span>

<span class="c"># 第三种方式：list装好所有值（运行时间最短——4秒多，内存占用低）</span>
<span class="n">start3</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
<span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">]</span>
<span class="n">a_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">b_list</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">df_list</span><span class="p">:</span>
     <span class="n">a_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">])</span>
     <span class="n">b_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s">&#39;b&#39;</span><span class="p">])</span>
<span class="n">res3</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s">&#39;a&#39;</span><span class="p">:</span> <span class="n">a_list</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">:</span> <span class="n">b_list</span><span class="p">})</span>

<span class="k">print</span><span class="p">(</span><span class="s">&#39;list装好所有值方式耗时：</span><span class="si">%s</span><span class="s">秒&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">start3</span><span class="p">))</span>
</pre></div>


<h3 id="232-join-merge-x8">2.3.2. join 代替 merge--x8加速</h3>
<p>使用<code>set_index</code> 将需要<code>merger</code>的key column 列设置为dataframe 的index，然后使用df.join 合并确实可以加速。</p>
<p><strong>加速前提</strong><br />
速度的提高将取决于您的<strong>索引是否唯一</strong>。如果索引不是唯一的，则在索引上合并两个数据帧可能甚至需要更长的时间</p>
<p><strong>原理</strong><br />
Indices have a <code>hash table</code>. Meaning you can look them up in amortized O(1). For a normal column you need O(n) in worst case, meaning merging two dfs with len n takes O(n^2) in worst case</p>
<div class="hlcode"><pre><span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="n">myids</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10000000</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="mi">1000000</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">df1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">myids</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">])</span>
<span class="n">df1</span><span class="p">[</span><span class="s">&#39;B&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1000</span><span class="p">,(</span><span class="mi">1000000</span><span class="p">))</span>
<span class="n">df2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">myids</span><span class="p">),</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;A2&#39;</span><span class="p">])</span>
<span class="n">df2</span><span class="p">[</span><span class="s">&#39;B2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1000</span><span class="p">,(</span><span class="mi">1000000</span><span class="p">))</span>

<span class="o">%%</span><span class="n">timeit</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">df1</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df2</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s">&#39;left&#39;</span><span class="p">,</span> <span class="n">left_on</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="n">right_on</span><span class="o">=</span><span class="s">&#39;A2&#39;</span><span class="p">)</span>   
<span class="c">#1 loop, best of 3: 664 ms per loop</span>

<span class="o">%%</span><span class="n">timeit</span>  
    <span class="n">x</span> <span class="o">=</span> <span class="n">df1</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">df2</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s">&#39;A2&#39;</span><span class="p">),</span> <span class="n">how</span><span class="o">=</span><span class="s">&#39;left&#39;</span><span class="p">)</span> 
<span class="c">#1 loop, best of 3: 354 ms per loop</span>

<span class="o">%%</span><span class="n">time</span> 
    <span class="n">df1</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">df2</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s">&#39;A2&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c">#Wall time: 16 ms</span>

<span class="o">%%</span><span class="n">timeit</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">df1</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">df2</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s">&#39;left&#39;</span><span class="p">)</span>
<span class="c">## </span>
<span class="n">df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s">&#39;key&#39;</span><span class="p">),</span> <span class="n">on</span><span class="o">=</span><span class="s">&#39;key&#39;</span><span class="p">)</span>
  <span class="n">key</span>   <span class="n">A</span>    <span class="n">B</span>
<span class="mi">0</span>  <span class="n">K0</span>  <span class="n">A0</span>   <span class="n">B0</span>
<span class="mi">1</span>  <span class="n">K1</span>  <span class="n">A1</span>   <span class="n">B1</span>
<span class="mi">2</span>  <span class="n">K2</span>  <span class="n">A2</span>   <span class="n">B2</span>
<span class="mi">3</span>  <span class="n">K3</span>  <span class="n">A3</span>  <span class="n">NaN</span>
<span class="mi">4</span>  <span class="n">K4</span>  <span class="n">A4</span>  <span class="n">NaN</span>
<span class="mi">5</span>  <span class="n">K5</span>  <span class="n">A5</span>  <span class="n">NaN</span>  
</pre></div>


<h2 id="24">2.4. 高效索引</h2>
<p>pandas DataFrame 条件筛选是通过布尔索引完成的，其效率非常高。</p>
<h3 id="241">2.4.1. 使用层次化索引筛选数据，避免使用条件逻辑筛选</h3>
<p>层次化索引(hierarchical indexing)是pandas的一个重要的功能，它可以在一个轴上有多个（两个以上）的索引，这就表示着，它能够以低维度形式来表示高维度的数据。</p>
<div class="hlcode"><pre><span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span>
                     <span class="n">index</span><span class="o">=</span><span class="p">[[</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="s">&quot;b&quot;</span><span class="p">,</span><span class="s">&quot;b&quot;</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]],</span>
                     <span class="n">columns</span><span class="o">=</span><span class="p">[[</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="s">&quot;B&quot;</span><span class="p">],[</span><span class="s">&quot;Z&quot;</span><span class="p">,</span><span class="s">&quot;X&quot;</span><span class="p">,</span><span class="s">&quot;C&quot;</span><span class="p">]])</span>
<span class="k">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">         A       B</span>
<span class="sd">         Z   X   C</span>
<span class="sd">    a 1  0   1   2</span>
<span class="sd">      2  3   4   5</span>
<span class="sd">    b 1  6   7   8</span>
<span class="sd">      2  9  10  11</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="c">#选取列,参数只能选取&quot;A&quot;或&quot;B&quot;</span>
<span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;A&quot;</span><span class="p">])</span><span class="c">#等价于data.ix[:,&quot;A&quot;]</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Z   X</span>
<span class="sd">a 1  0   1</span>
<span class="sd">    2  3   4</span>
<span class="sd">b 1  6   7</span>
<span class="sd">    2  9  10</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="c">#选取行</span>
<span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="s">&quot;a&quot;</span><span class="p">])</span>
<span class="s">&#39;&#39;&#39;</span>
<span class="s">    A     B</span>
<span class="s">    Z  X  C</span>
<span class="s">1  0  1  2</span>
<span class="s">2  3  4  5</span>
<span class="s">&quot;&quot;&quot;</span>
</pre></div>


<ol>
<li>df-&gt;Series,先把table_s转为层次化索引的Series，</li>
<li>Series--索引--&gt;数据。然后按索引值直接检索数据，</li>
</ol>
<p>这比采用形如<code>df[(df.col1==a)&amp;(df.col2==b)]</code>这种条件逻辑筛选法程序更简洁，运行也更快一些。</p>
<h3 id="242-locilocixat">2.4.2. 正确使用 loc\iloc\ix\at</h3>
<p><code>df.loc[i,c]</code> 能够选取多行多列</p>
<p><code>df.at[i,c]</code> 一次只能访问一个值，同等条件下比<code>loc</code>快10倍速</p>
<div class="hlcode"><pre><span class="o">%%</span><span class="n">timeit</span>
<span class="n">outdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">indf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="mi">100</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">11.7</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>

<span class="o">%%</span><span class="n">timeit</span> 
<span class="n">outdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">indf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="mi">100</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">11.4</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>

<span class="o">%%</span><span class="n">timeit</span> 
<span class="n">outdf</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">indf</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="mi">100</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">11.6</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>


<span class="o">%%</span><span class="n">timeit</span>
<span class="n">outdf</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="s">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">indf</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="s">&#39;time&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="mi">10000</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">25.3</span> <span class="err">µ</span><span class="n">s</span> <span class="n">per</span> <span class="n">loop</span>
</pre></div>


<h3 id="243-copy-vs-view">2.4.3. copy vs view</h3>
<p>尽量使用切片而不是列表</p>
<div class="hlcode"><pre><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span><span class="mi">10</span><span class="p">:</span><span class="mi">20</span><span class="p">]</span> <span class="c"># 更好</span>

<span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,[</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="mi">20</span><span class="p">]]</span> <span class="c">#差</span>
</pre></div>


<h2 id="25-numpy-numpy">2.5. 能改成numpy 就numpy</h2>
<p><strong>给numpy数据一个名字</strong> <br />
我喜欢用 pandas, 因为 pandas 能让你给数据命名, 用名字来做 index. 在数据类型很多的时候, 名字总是比 index 好记太多了, 也好用太多了. 但是 pandas 的确比 numpy 慢. 好在我们还是有途径可以实现用名字来索引. 这就是 structured array. 下面 a/b 的结构是一样的, 只是一个是 numpy 一个是 pandas.</p>
<div class="hlcode"><pre><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;foo&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;bar&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">)])</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;foo&#39;</span><span class="p">,</span> <span class="s">&#39;bar&#39;</span><span class="p">])</span>
<span class="n">b</span><span class="p">[</span><span class="s">&#39;bar&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="s">&#39;bar&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">)</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd"># a</span>
<span class="sd">array([(0,  0.), (0,  0.), (0,  0.)],</span>
<span class="sd">      dtype=[(&#39;foo&#39;, &#39;&lt;i4&#39;), (&#39;bar&#39;, &#39;&lt;f2&#39;)])</span>

<span class="sd"># b</span>
<span class="sd">   foo  bar</span>
<span class="sd">0    0  0.0</span>
<span class="sd">1    0  0.0</span>
<span class="sd">2    0  0.0</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">f1</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">a</span><span class="p">[</span><span class="s">&#39;bar&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="n">a</span><span class="p">[</span><span class="s">&#39;foo&#39;</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">f2</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">b</span><span class="p">[</span><span class="s">&#39;bar&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="n">b</span><span class="p">[</span><span class="s">&#39;foo&#39;</span><span class="p">]</span>

<span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">((</span><span class="n">t1</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span><span class="o">/</span><span class="n">N</span><span class="p">))</span>    <span class="c"># 0.000003</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">((</span><span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="p">)</span><span class="o">/</span><span class="n">N</span><span class="p">))</span>    <span class="c"># 0.000508</span>
</pre></div>


<h2 id="26">2.6. 多线程并行计算</h2>
<p>由于Pandas的一些操作都是单核的，往往浪费其他核的计算时间。</p>
<p>使用多CPU核心分块并行运算，对于可分块运行的数据运算任务，可使用多线程类编程，调用多个CPU核心并行工作提高速度。</p>
<h3 id="261-multiprocessingpool">2.6.1. multiprocessing.Pool</h3>
<p>因为 GIL 的缘故 threading 不能用，那么我们就好好研究研究 multiprocessing。（当然，如果你说你不用 CPython，没有 GIL 的问题，那也是极佳的。）</p>
<p>首先介绍一个简单粗暴，非常实用的工具，就是 <code>multiprocessing.Pool</code>。如果你的任务能用<code>ys = map(f, xs)</code> 来解决，大家可能都知道，这样的形式天生就是最容易并行的，那么在 Python 里面并行计算这个任务真是再简单不过了。举个例子，把每个数都平方：</p>
<div class="hlcode"><pre><span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">_sleep_time</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mi">10</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">_sleep_time</span><span class="p">)</span>
    <span class="k">print</span> <span class="p">(</span><span class="s">&quot;sleep {} s&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">_sleep_time</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="k">def</span> <span class="nf">f2</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">_sleep_time</span><span class="o">=</span><span class="n">x</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">_sleep_time</span><span class="p">)</span>
    <span class="k">print</span> <span class="p">(</span><span class="s">&quot;sleep {} s&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">_sleep_time</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>


<span class="n">cores</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
<span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">cores</span><span class="p">)</span>
<span class="n">xs</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="c"># method 0:  built-in function map</span>
<span class="o">%%</span><span class="n">timeit</span>
<span class="k">print</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">xs</span><span class="p">)))</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="c"># 0 sleep 3.6515010268734596 s</span>
<span class="c"># 1 sleep 9.622811159423282 s</span>
<span class="c"># 2 sleep 4.5357524694481075 s</span>
<span class="c"># 3 sleep 0.06634438382474794 s</span>
<span class="c"># 4 sleep 9.26407616547759 s</span>
<span class="c"># [0, 1, 4, 9, 16]</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">有序输入，与形参无关的全局变量每次确定，返回有序</span>
<span class="sd">python-level loop</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="k">print</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">f2</span><span class="p">,</span><span class="n">xs</span><span class="p">)))</span>
<span class="o">&gt;&gt;&gt;...</span>
<span class="c"># 10s</span>


<span class="c"># method 1: map</span>
<span class="k">print</span> <span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">xs</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="c"># 3 sleep 3.6515010268734596 s</span>
<span class="c"># 4 sleep 3.6515010268734596 s</span>
<span class="c"># 2 sleep 3.6515010268734596 s</span>
<span class="c"># 1 sleep 3.6515010268734596 s</span>
<span class="c"># 0 sleep 3.6515010268734596 s</span>
<span class="c"># [0, 1, 4, 9, 16]</span>
<span class="sd">&quot;&quot;&quot;无序输入，与形参无关的全局变量一次确定，返回有序</span>
<span class="sd">shuffle-map-reduce</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="k">print</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">f2</span><span class="p">,</span><span class="n">xs</span><span class="p">)))</span>
<span class="o">&gt;&gt;&gt;...</span>
<span class="c"># 4s 多线程 分配计算，合并</span>

<span class="c"># method 2: imap</span>
<span class="c"># 返回的是迭代器</span>
<span class="k">print</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">xs</span><span class="p">)))</span>
<span class="c"># 0 sleep 4.854476661038866 s</span>
<span class="c"># 2 sleep 4.854476661038866 s</span>
<span class="c"># 4 sleep 4.854476661038866 s</span>
<span class="c"># 1 sleep 4.854476661038866 s</span>
<span class="c"># 3 sleep 4.854476661038866 s</span>
<span class="c"># [0, 1, 4, 9, 16]</span>
<span class="sd">&quot;&quot;&quot;无序输入，与形参无关的全局变量一次确定，返回有序</span>
<span class="sd">shuffle-map-reduce</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c"># method 3: imap_unordered</span>
<span class="c"># 返回的是迭代器</span>
<span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">pool</span><span class="o">.</span><span class="n">imap_unordered</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">xs</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="k">print</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">imap_unordered</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">xs</span><span class="p">)))</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="c"># 2 sleep 2.1295588889839454 s</span>
<span class="c"># 1 sleep 2.1295588889839454 s</span>
<span class="c"># 0 sleep 2.1295588889839454 s</span>
<span class="c"># 3 sleep 8.694609405762515 s</span>
<span class="c"># 4 sleep 8.694609405762515 s</span>
<span class="c"># [0, 4, 1, 9, 16]</span>

<span class="sd">&quot;&quot;&quot;无序输入，与形参无关的全局变量分次确定，返回有序</span>
<span class="sd">shuffle-map</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>


<p>当计算时间比较长的时候，我们可能想要加上一个进度条，这个时候 i 系列的好处就体现出来了。另外，有一个小技巧，就是输出 <code>\r</code> 可以使得光标回到行首而不换行，这样就可以制作简易的进度条了。</p>
<div class="hlcode"><pre><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">pool</span><span class="o">.</span><span class="n">imap_unordered</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">xs</span><span class="p">):</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;done </span><span class="si">%d</span><span class="s">/</span><span class="si">%d</span><span class="se">\r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)))</span>
    <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>


<p><sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup></p>
<h1 id="3-pandas">3. 更小的pandas</h1>
<div class="hlcode"><pre><span class="c"># 查看内存占用情况</span>
<span class="n">df</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="o">&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">pandas</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">DataFrame</span><span class="s">&#39;&gt;</span>
<span class="n">Index</span><span class="p">:</span> <span class="mi">1034849</span> <span class="n">entries</span><span class="p">,</span> <span class="n">_14680064</span> <span class="n">to</span> <span class="n">_6291451</span>
<span class="n">Columns</span><span class="p">:</span> <span class="mi">212</span> <span class="n">entries</span><span class="p">,</span> <span class="mi">2016</span><span class="o">-</span><span class="mo">01</span><span class="o">-</span><span class="mo">01</span> <span class="n">to</span> <span class="mi">2016</span><span class="o">-</span><span class="mo">07</span><span class="o">-</span><span class="mi">30</span>
<span class="n">dtypes</span><span class="p">:</span> <span class="n">float64</span><span class="p">(</span><span class="mi">212</span><span class="p">)</span>
<span class="n">memory</span> <span class="n">usage</span><span class="p">:</span> <span class="mf">1.6</span><span class="o">+</span> <span class="n">GB</span>
</pre></div>


<h2 id="31">3.1. 降低数据精度</h2>
<p>pandas中常用类型的数据类型内存占用大小情况：<br />
<img alt="" src="../../../../../attach/images/2020-03-05-09-18-28.png" /></p>
<p>Pandas dtype mapping<br />
| Pandas dtype | Python type | NumPy type | Usage |<br />
| ------------ | ----------- | ---------- | ----- ||  |  |<br />
| object        | str         | string_, unicode_                                              | Text                              |<br />
| int64         | int         | int_, int8, int16, int32, int64, uint8, uint16, uint32, uint64 | Integer numbers                   |<br />
| float64       | float       | float_, float16, float32, float64                              | Floating point numbers            |<br />
| bool          | bool        | bool_                                                          | True/False values                 |<br />
| datetime64    | NA          | datetime64[ns]                                                 | Date and time values              |<br />
| timedelta[ns] | NA          | NA                                                             | Differences between two datetimes |<br />
| category      | NA          | NA                                                             | Finite list of text values        |</p>
<p><strong>主要思路</strong><br />
1. 将数值型列降级到更高效的类型(例如:float64-&gt;float32)<br />
2. 将字符串列转换为类别类型</p>
<div class="hlcode"><pre><span class="c"># float 类型</span>
<span class="n">gl_float</span> <span class="o">=</span> <span class="n">gl</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;float&#39;</span><span class="p">])</span>
<span class="n">converted_float</span> <span class="o">=</span> <span class="n">gl_float</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">,</span><span class="n">downcast</span><span class="o">=</span><span class="s">&#39;float&#39;</span><span class="p">)</span>

<span class="c">#category (暂不推荐)</span>
<span class="c">#对于独特值少，重复值多的列有较好的效果</span>
<span class="n">dow_cat</span> <span class="o">=</span> <span class="n">dow</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">&#39;category&#39;</span><span class="p">)</span>
</pre></div>


<h3 id="311">3.1.1. 数据读取时</h3>
<p>使用pd.read_csv()读取数据时，默认按64位精度读取数据，且有的数据读取为object类型，这些都极耗内存。可根据实际需要采用低位精度读取，并指定object类型为实际的类型或category类型，只读取需要处理的列。如</p>
<div class="hlcode"><pre><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;O_LINENO&#39;</span><span class="p">,</span><span class="s">&#39;O_TERMINALNO&#39;</span><span class="p">,</span><span class="s">&#39;O_TIME&#39;</span><span class="p">,</span><span class="s">&#39;O_UP&#39;</span><span class="p">,</span><span class="s">&#39;O_NEXTSTATIONNO&#39;</span><span class="p">]</span>
<span class="n">col_types</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;uint16&#39;</span><span class="p">,</span><span class="s">&#39;int32&#39;</span><span class="p">,</span><span class="s">&#39;category&#39;</span><span class="p">,</span><span class="s">&#39;int8&#39;</span><span class="p">,</span><span class="s">&#39;uint8&#39;</span><span class="p">]</span>
<span class="n">columns_types</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">col_types</span><span class="p">))</span>
<span class="n">table_all</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">FOLDER</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">&#39;</span> <span class="o">+</span> <span class="s">&#39;table_all.csv&#39;</span><span class="p">,</span><span class="n">usecols</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">columns_types</span><span class="p">)</span>
<span class="n">table_all</span><span class="o">.</span><span class="n">O_TIME</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">table_all</span><span class="o">.</span><span class="n">O_TIME</span><span class="p">)</span>
</pre></div>


<h3 id="312">3.1.2. 优化数据结构</h3>
<h4 id="3121">3.1.2.1. 稀疏矩阵</h4>
<h2 id="32">3.2. 优化字符串对象</h2>
<h3 id="321">3.2.1. 字符串内存占用组成</h3>
<div class="hlcode"><pre><span class="kn">import</span> <span class="nn">sys</span>

<span class="c"># 空的二进制对象</span>
<span class="n">val</span><span class="o">=</span><span class="n">b</span><span class="s">&quot;&quot;</span> 

<span class="c"># 空的unicode对象</span>
<span class="n">unicode_val</span><span class="o">=</span><span class="s">u&quot;&quot;</span>
<span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="mi">33</span>
<span class="c"># 32+1 (nul) Python中的字符串是nul终止的</span>

<span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="n">unicode_val</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> 
<span class="mi">49</span>
<span class="c"># 48+1(nul)</span>
</pre></div>


<p>pandas 中 ：</p>
<div class="hlcode"><pre><span class="cp"># 内存占用情况</span>
<span class="mi">8</span> <span class="p">(</span><span class="n">PyObject</span><span class="o">*</span><span class="p">)</span> <span class="o">+</span> <span class="mi">48</span> <span class="p">(</span><span class="n">Python</span> <span class="n">C</span> <span class="k">struct</span><span class="p">)</span> <span class="o">+</span> <span class="n">string_length</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>


<p><strong>问题</strong> <br />
pandas Dataframe 中可能存在(m,n)行列，数据巨大时候，意味着存在多个不长的字符串对象，每个字符串对象都 需要占用一个<code>8 (PyObject*) + 48 (Python C struct)</code>内存</p>
<div class="hlcode"><pre><span class="n">df</span><span class="o">.</span><span class="n">shape</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="p">(</span><span class="mi">1000000</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c"># 10字符串长度</span>
<span class="c">#10MB-&gt;./test.csv</span>
<span class="c">#60MB-&gt;df</span>
</pre></div>


<h1 id="4-numpy">4. 使用numpy 代替</h1>
<p>我喜欢用 pandas, 因为 pandas 能让你给数据命名, 用名字来做 index. 在数据类型很多的时候, 名字总是比 index 好记太多了, 也好用太多了. 但是 pandas 的确比 numpy 慢. 好在我们还是有途径可以实现用名字来索引. 这就是 structured array. 下面 a/b 的结构是一样的, 只是一个是 numpy 一个是 pandas.</p>
<div class="hlcode"><pre><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;foo&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;bar&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">)])</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;foo&#39;</span><span class="p">,</span> <span class="s">&#39;bar&#39;</span><span class="p">])</span>
<span class="n">b</span><span class="p">[</span><span class="s">&#39;bar&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="s">&#39;bar&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">)</span>


<span class="c"># 5. a</span>
<span class="n">array</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">)],</span>
      <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;foo&#39;</span><span class="p">,</span> <span class="s">&#39;&lt;i4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;bar&#39;</span><span class="p">,</span> <span class="s">&#39;&lt;f2&#39;</span><span class="p">)])</span>

<span class="c"># 6. b</span>
   <span class="n">foo</span>  <span class="n">bar</span>
<span class="mi">0</span>    <span class="mi">0</span>  <span class="mf">0.0</span>
<span class="mi">1</span>    <span class="mi">0</span>  <span class="mf">0.0</span>
<span class="mi">2</span>    <span class="mi">0</span>  <span class="mf">0.0</span>


<span class="k">def</span> <span class="nf">f1</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">a</span><span class="p">[</span><span class="s">&#39;bar&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="n">a</span><span class="p">[</span><span class="s">&#39;foo&#39;</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">f2</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">b</span><span class="p">[</span><span class="s">&#39;bar&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="n">b</span><span class="p">[</span><span class="s">&#39;foo&#39;</span><span class="p">]</span>

<span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">((</span><span class="n">t1</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span><span class="o">/</span><span class="n">N</span><span class="p">))</span>    <span class="c"># 0.000003</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">((</span><span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="p">)</span><span class="o">/</span><span class="n">N</span><span class="p">))</span>    <span class="c"># 0.000508</span>
</pre></div>


<p>可以看出来, numpy 明显比 pandas 快很多. 如果需要使用到不同数据形式, numpy 也是可以胜任的, 并且在还保持了快速的计算速度. 至于 pandas 为什么比 numpy 慢, 因为 pandas data 里面还有很多七七八八的数据, 记录着这个 data 的种种其他的特征。</p>
<h1 id="5">5. 参考资料</h1>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>How To Make Your Pandas Loop 71803 Times Faster https://towardsdatascience.com/how-to-make-your-pandas-loop-71-803-times-faster-805030df4f06&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/enhancingperf.html#expression-evaluation-via-eval">官方文档Enhancing performance</a>&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:fake_vectorize">
<p>Stackoverflow:<a href="https://stackoverflow.com/questions/52673285/performance-of-pandas-apply-vs-np-vectorize-to-create-new-column-from-existing-c">Performance of Pandas apply vs np.vectorize to create new column from existing columns</a>&#160;<a class="footnote-backref" href="#fnref:fake_vectorize" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:fast_groupby">
<p>Fast groupby <a href="http://esantorella.com/2016/06/16/groupby/">Fast groupby-apply operations in Python with and without Pandas</a>&#160;<a class="footnote-backref" href="#fnref:fast_groupby" rev="footnote" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:best_format">
<p><a href="https://towardsdatascience.com/the-best-format-to-save-pandas-data-414dca023e0d">The Best Format to Save Pandas Data</a>&#160;<a class="footnote-backref" href="#fnref:best_format" rev="footnote" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
</ol>
</div>
</div>
<div id="renote">
  <HR style=" FILTER: alpha (opacity = 100, finishopacity =0 , style= 3 )" width="80%" color=#987 cb 9 SIZE=3>
  <p>如果你觉得这篇文章对你有帮助，不妨请我喝杯咖啡，鼓励我创造更多!</p>
  <img src="/Wiki/static/images/pay.jpg" width="25%">
</div>

    </div>
    <div id="footer">
        <span>
            Copyright © 2020 zhang787jun.
            Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.
        </span>
    </div>

    
</body>
<script>
    function changeImgurl(site_root_url) {
        var images = document.images;
        var site_root = site_root_url;
        for (i = 0, len = images.length; i < len; i++) {
            image = images[i];
            image_src = image.src;
            if (image_src.search("attach") >= 0) {
                re_image_src = image_src.slice(image_src.search("attach"));
                abs_image_src = (site_root.endsWith("/")) ? site_root + re_image_src : site_root + "/" +
                    re_image_src;
                image.src = abs_image_src;
            }
        }
    }
    var site_root_url = "/Wiki";
    changeImgurl(site_root_url);
    let isMathjaxConfig = false; // 防止重复调用Config，造成性能损耗
    const initMathjaxConfig = () => {
        if (!window.MathJax) {
            return;
        }
        window.MathJax.Hub.Config({
            showProcessingMessages: false, //关闭js加载过程信息
            messageStyle: "none", //不显示信息
            jax: ["input/TeX", "output/HTML-CSS"],
            tex2jax: {
                inlineMath: [["$", "$"], ["\\(", "\\)"]], //行内公式选择符
                displayMath: [["$$", "$$"], ["\\[", "\\]"]], //段内公式选择符
                skipTags: ["script", "noscript", "style", "textarea", "pre", "code", "a"] //避开某些标签
            },
            "HTML-CSS": {
                availableFonts: ["STIX", "TeX"], //可选字体
                showMathMenu: false //关闭右击菜单显示
            }
        });
        isMathjaxConfig = true; //
    };
    if (isMathjaxConfig === false) {
        // 如果：没有配置MathJax
        initMathjaxConfig();
    };
</script>

</html>