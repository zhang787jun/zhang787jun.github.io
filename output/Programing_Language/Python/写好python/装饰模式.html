<!DOCTYPE HTML>
<html>

<head>
    <link rel="Stylesheet" type="text/css" href="/Wiki/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/Wiki/static/css/tango.css">
    <link rel="shortcut icon" href="/Wiki/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/Wiki/favicon.ico" type="image/x-icon">
    <title>Python--装饰模式、修饰器讨论 - Jun's personal knowledge wiki</title>
    <meta name="keywords" content="Technology, MachineLearning, DataMining, Wiki" />
    <meta name="description" content="A wiki website" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
            }
        });
    </script>
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
        </script>
</head>

<body>

    <div id="container">
        
<div id="header">
  <div id="post-nav"><a href="/Wiki/">Home</a>&nbsp;»&nbsp;<a href="/Wiki/#Programing_Language\Python\写好python">Programing_Language\Python\写好python</a>&nbsp;»&nbsp;Python--装饰模式、修饰器讨论</div>
</div>
<div class="clearfix"></div>
<div id="title">Python--装饰模式、修饰器讨论</div>
<div id="content">
  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#1">1. 装饰模式</a><ul>
<li><a href="#11">1.1. 设计模式中的装饰模式</a></li>
</ul>
</li>
<li><a href="#2">2. 修饰器@</a><ul>
<li><a href="#21">2.1. 基本定性</a></li>
<li><a href="#22">2.2. 详解</a><ul>
<li><a href="#221">2.2.1. 简单修饰器</a></li>
<li><a href="#222">2.2.2. 内置修饰器</a><ul>
<li><a href="#2221-staticmethod">2.2.2.1. @staticmethod</a></li>
<li><a href="#2222-classmethod-">2.2.2.2. @classmethod--类方法</a></li>
<li><a href="#2223-property-">2.2.2.3. @property--属性</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#23">2.3. 进阶修饰器</a><ul>
<li><a href="#231">2.3.1. 原函数有参数传入</a><ul>
<li><a href="#2311">2.3.1.1. 原函数有确定参数输入</a></li>
<li><a href="#2312">2.3.1.2. 原函数可变参数输入</a></li>
<li><a href="#2313">2.3.1.3. 原函数字典参数输入</a></li>
</ul>
</li>
<li><a href="#232">2.3.2. 装饰器有参数传入</a></li>
</ul>
</li>
<li><a href="#24">2.4. 装饰器顺序</a></li>
<li><a href="#25">2.5. 装饰器类</a></li>
</ul>
</li>
<li><a href="#3">3. 好用的实例</a><ul>
<li><a href="#31">3.1. 实现对异常进行捕获或重试</a></li>
<li><a href="#32">3.2. 确保数据库连接关闭</a></li>
</ul>
</li>
</ul>
</div>
<h1 id="1">1. 装饰模式</h1>
<p>都看装饰器这么长时间了，再来看看。</p>
<h2 id="11">1.1. 设计模式中的装饰模式</h2>
<p>装饰模式（Decorator Pattern）指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。</p>
<p><img alt="" src="../../../attach/images/2019-08-21-17-24-27.png" /></p>
<div class="hlcode"><pre><span class="nd">@decorator</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">():</span>
    <span class="k">pass</span>
<span class="err">其解释器会解释成下面这样的语句：</span>

<span class="n">func</span> <span class="o">=</span> <span class="n">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
</pre></div>


<h1 id="2">2. 修饰器@</h1>
<p><strong>函数就是用来写core 函数的</strong>--路飞</p>
<h3 id="21">2.1. 基本定性</h3>
<p>装饰器本质上是一个高级Python函数，通过给别的函数添加@标识的形式实现对函数的装饰，这个函数的特殊之处在于它的返回值也是一个函数</p>
<p><strong>优势：</strong><br />
1. 可以让其他函数在不需要做任何代码变动的前提下增加额外功能</p>
<p><strong>应用场景：</strong></p>
<p>经常用于有切面需求的场景，例如: <br />
1. 插入日志<br />
2. 性能测试<br />
3. 事务处理<br />
4. 缓存<br />
5. 权限校验等场景</p>
<p>有了装饰器，我们就可以抽离出大量<strong>与函数功能本身无关</strong>的<strong>雷同代码</strong>并继续重用。</p>
<h3 id="22">2.2. 详解</h3>
<h4 id="221">2.2.1. 简单修饰器</h4>
<p><strong>3个关键函数</strong></p>
<p>关于 decorator, 基本上一共有三个函数:<br />
1. decorator: 修饰器/修饰函数<br />
2. orifunc: 原函数/被修饰函数<br />
3. wrapper: 新函数/取代函数/闭包函数</p>
<p>简单的可以标识为:</p>
<div class="hlcode"><pre><span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">orifunc</span><span class="p">):</span>
    <span class="c"># do something here (register...)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c"># do something before (preprocess)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">orifunc</span><span class="p">()</span>
        <span class="c"># do something after (postprocess)</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>


<p>它们的关系是:</p>
<div class="hlcode"><pre><span class="n">wrapper</span> <span class="o">=</span> <span class="n">decorator</span><span class="p">(</span><span class="n">orifunc</span><span class="p">)</span>
</pre></div>


<p>上述表示等同于</p>
<div class="hlcode"><pre><span class="nd">@decorator</span>
<span class="k">def</span> <span class="nf">orifunc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c"># do something...</span>
</pre></div>


<p><strong>执行顺序</strong></p>
<div class="hlcode"><pre><span class="k">def</span> <span class="nf">Timer</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">newFunc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">args2</span><span class="p">):</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
        <span class="k">print</span> <span class="p">(</span><span class="s">&quot;[1]&quot;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">args2</span><span class="p">)</span>
        <span class="n">t2</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
        <span class="k">print</span> <span class="p">(</span><span class="s">&quot;[3]&quot;</span><span class="p">)</span>
        <span class="n">cost_time</span><span class="o">=</span><span class="n">t2</span><span class="o">-</span><span class="n">t1</span>
        <span class="k">print</span> <span class="p">(</span><span class="s">&quot; This function【{}】cost time:{} </span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span><span class="n">cost_time</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">newFunc</span>

<span class="nd">@Timer</span>
<span class="k">def</span> <span class="nf">Pi</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="c">#N=10**7</span>
    <span class="n">N</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">data</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">inside</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">data</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">pi</span><span class="o">=</span><span class="mi">4</span><span class="o">*</span><span class="n">inside</span><span class="o">/</span><span class="n">N</span>
    <span class="k">print</span> <span class="p">(</span><span class="s">&quot;[2] pi is </span><span class="si">%.5f</span><span class="s">&quot;</span><span class="o">%</span><span class="n">pi</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> 
<span class="s">&quot;[1]&quot;</span>
<span class="s">&quot;[2]  pi is 3.1415&quot;</span>
<span class="s">&quot;[3]&quot;</span>
<span class="s">&quot;This function Pi cost time:{}&quot;</span>
</pre></div>


<h4 id="222">2.2.2. 内置修饰器</h4>
<p>修饰器可以自定义，同时，python中也有自定义的几个修饰器<br />
内置的装饰器有三个，分别是staticmethod、classmethod和property，作用分别是把类中定义的实例方法变成静态方法、类方法和类属性。</p>
<p>使用频率也非常低。</p>
<p>而使用@staticmethod或@classmethod，就可以不需要实例化，直接类名.方法名()来调用。</p>
<p>这有利于组织代码，把某些应该属于某个类的函数给放到那个类里去，同时有利于命名空间的整洁。</p>
<p>既然@staticmethod和@classmethod都可以直接类名.方法名()来调用，那他们有什么区别呢</p>
<p>从它们的使用上来看,<br />
@staticmethod不需要表示自身对象的self和自身类的cls参数，就跟使用函数一样。<br />
@classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数。<br />
如果在@staticmethod中要调用到这个类的一些属性方法，只能直接类名.属性名或类名.方法名。</p>
<p>而@classmethod因为持有cls参数，可以来调用类的属性，类的方法，实例化对象等，避免硬编码。</p>
<p>下面上代码。</p>
<h5 id="2221-staticmethod">2.2.2.1. @staticmethod</h5>
<p>一般来说，要使用某个类的方法，需要先实例化一个对象再调用方法。直接类名.方法名()来调用，不需要实例化类。</p>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">=</span><span class="n">name</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">static_foo</span><span class="p">():</span>
        <span class="k">print</span> <span class="s">&#39;static_foo&#39;</span>

<span class="n">A</span><span class="o">.</span><span class="n">static_foo</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="n">static_foo</span>


<span class="n">class_instance</span><span class="o">=</span><span class="n">A</span><span class="p">(</span><span class="s">&quot;name_1&quot;</span><span class="p">)</span>
<span class="n">class_instance</span><span class="o">.</span><span class="n">static_foo</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="n">static_foo</span>
</pre></div>


<h5 id="2222-classmethod-">2.2.2.2. @classmethod--类方法</h5>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">bar</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&#39;foo&#39;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">static_foo</span><span class="p">():</span>
        <span class="k">print</span> <span class="s">&#39;static_foo&#39;</span>
        <span class="k">print</span> <span class="n">A</span><span class="o">.</span><span class="n">bar</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">class_foo</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&#39;class_foo&#39;</span>
        <span class="k">print</span> <span class="n">cls</span><span class="o">.</span><span class="n">bar</span>
        <span class="n">cls</span><span class="p">()</span><span class="o">.</span><span class="n">foo</span><span class="p">()</span>

<span class="n">A</span><span class="o">.</span><span class="n">class_foo</span><span class="p">()</span>

<span class="o">&gt;&gt;&gt;</span>
<span class="n">class_foo</span>
<span class="mi">1</span>
<span class="n">foo</span>
</pre></div>


<h5 id="2223-property-">2.2.2.3. @property--属性</h5>
<p>在绑定类属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改：</p>
<div class="hlcode"><pre><span class="n">s</span> <span class="o">=</span> <span class="n">Student</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="mi">9999</span> <span class="c"># 成绩不能大于100 ，参数值不合理 </span>
</pre></div>


<p>这显然不合逻辑。<strong>为了限制score的范围</strong>，可以通过一个set_score()方法来设置成绩，再通过一个get_score()来获取成绩，这样，在set_score()方法里，就可以检查参数：</p>
<div class="hlcode"><pre><span class="n">class</span> <span class="n">Student</span><span class="p">(</span><span class="n">object</span><span class="p">)</span><span class="o">:</span>
    <span class="n">def</span> <span class="n">get_score</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">:</span>
         <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">_score</span>

    <span class="n">def</span> <span class="n">set_score</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span><span class="o">:</span>
        <span class="k">if</span> <span class="n">not</span> <span class="n">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">:</span>
            <span class="n">raise</span> <span class="n">ValueError</span><span class="p">(</span><span class="err">&#39;</span><span class="n">score</span> <span class="n">must</span> <span class="n">be</span> <span class="n">an</span> <span class="n">integer</span><span class="o">!</span><span class="err">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="n">or</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="o">:</span>
            <span class="n">raise</span> <span class="n">ValueError</span><span class="p">(</span><span class="err">&#39;</span><span class="n">score</span> <span class="n">must</span> <span class="n">between</span> <span class="mi">0</span> <span class="o">~</span> <span class="mi">100</span><span class="o">!</span><span class="err">&#39;</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">_score</span> <span class="o">=</span> <span class="n">value</span>
</pre></div>


<p>还记得装饰器（decorator）可以给函数动态加上功能吗？对于类的方法，装饰器一样起作用。Python内置的@property装饰器就是负责把一个方法变成属性调用的：</p>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Student</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score</span>

    <span class="nd">@score.setter</span>
    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;score must be an integer!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;score must between 0 ~ 100!&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_score</span> <span class="o">=</span> <span class="n">value</span>
</pre></div>


<p>@property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作：</p>
<p>还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性：</p>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Student</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">birth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_birth</span>

    <span class="nd">@birth.setter</span>
    <span class="k">def</span> <span class="nf">birth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_birth</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">age</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">2015</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_birth</span>
</pre></div>


<p>上面的birth是可读写属性，而age就是一个只读属性，因为age可以根据birth和当前时间计算出来</p>
<h3 id="23">2.3. 进阶修饰器</h3>
<h4 id="231">2.3.1. 原函数有参数传入</h4>
<p>python 中函数的参数分为<br />
1.必选参数<br />
2.默认参数<br />
3.可变参数 <em>args  仅仅在参数前面加了一个</em>号。<br />
4.关键字参数 **kw</p>
<h6 id="2311">2.3.1.1. 原函数有确定参数输入</h6>
<div class="hlcode"><pre><span class="c"># 非语法糖</span>
<span class="k">def</span> <span class="nf">use_logging</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> is running&quot;</span> <span class="o">%</span> <span class="n">func</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>   <span class="c"># 把 orifunc 当做参数传递进来时，执行func()就相当于执行 orifunc()</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="k">def</span> <span class="nf">orifunc</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;i am {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
<span class="c"># 因为装饰器 use_logging(foo) 返回的时函数对象 wrapper，这条语句相当于  orifunc = wrapper</span>
<span class="c"># orifunc()就相当于执行 wrapper()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">orifunc</span> <span class="o">=</span> <span class="n">use_logging</span><span class="p">(</span><span class="n">orifunc</span><span class="p">)</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="n">orifunc</span><span class="p">(</span><span class="s">&quot;me&quot;</span><span class="p">)</span>


<span class="c"># 语法糖</span>
<span class="k">def</span> <span class="nf">use_logging</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> is running&quot;</span> <span class="o">%</span> <span class="n">func</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="nd">@use_logging</span>
<span class="k">def</span> <span class="nf">orifunc</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;i am {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">orifunc</span><span class="p">(</span><span class="s">&quot;me&quot;</span><span class="p">)</span>
</pre></div>


<h6 id="2312">2.3.1.2. 原函数可变参数输入</h6>
<div class="hlcode"><pre><span class="c">#------[2] 参数列表输入</span>


<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;i am </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> is running&quot;</span> <span class="o">%</span> <span class="n">func</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>


<h6 id="2313">2.3.1.3. 原函数字典参数输入</h6>
<div class="hlcode"><pre><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;I am </span><span class="si">%s</span><span class="s">, age </span><span class="si">%s</span><span class="s">, height </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">height</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c"># args是一个数组，kwargs一个字典</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> is running&quot;</span> <span class="o">%</span> <span class="n">func</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>


<h4 id="232">2.3.2. 装饰器有参数传入</h4>
<p>有多种方式让装饰器接受可选参数。根据你是想使用位置参数、关键字参数还是两者皆是，需要使用稍微不同的模式。如下我将展示一种接受一个可选关键字参数的方式：<br />
1.定义3层闭包<br />
2.Layer 1 最外层形参用来接收装饰器参数<br />
3.Layer 2 第二层用来接受被修饰的原函数<br />
4.Layer 3 第三层用来传递原函数的参数</p>
<div class="hlcode"><pre><span class="k">def</span> <span class="nf">nominally_decorator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kw</span><span class="p">):</span>       
    <span class="c"># Layer 1  *args,**kw 为nominally_decorator的参数</span>
    <span class="k">def</span> <span class="nf">core_decorator</span><span class="p">(</span><span class="n">orifunc</span><span class="p">):</span>           
        <span class="c"># Layer 2 第二层用来接受被修饰的原函数</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">arguments_for_orifunc</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_for_orifunc</span><span class="p">):</span> 
            <span class="c"># Layer 3 Layer 3 第三层用来传递原函数的参数</span>

            <span class="c"># do something before (preprocess)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">orifunc</span><span class="p">(</span><span class="o">*</span><span class="n">arguments_for_orifunc</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_for_orifunc</span><span class="p">)</span>
            <span class="c"># do something after (postprocess)</span>

            <span class="k">return</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">wrapper</span>
    <span class="k">return</span> <span class="n">core_decorator</span>
</pre></div>


<div class="hlcode"><pre><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="k">def</span> <span class="nf">typeassert</span><span class="p">(</span><span class="o">*</span><span class="n">ty_args</span><span class="p">,</span> <span class="o">**</span><span class="n">ty_kwargs</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorate</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="c"># If in optimized mode, disable type checking 关闭类型检测模式</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">__debug__</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">func</span>
        <span class="c"># 通过signature方法，获取函数形参：name, age, height</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="n">bound_types</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">bind_partial</span><span class="p">(</span><span class="o">*</span><span class="n">ty_args</span><span class="p">,</span> <span class="o">**</span><span class="n">ty_kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">arguments</span>

        <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">bound_values</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c"># Enforce type assertions across supplied arguments</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">bound_values</span><span class="o">.</span><span class="n">arguments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">bound_types</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">bound_types</span><span class="p">[</span><span class="n">name</span><span class="p">]):</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="s">&#39;Argument {} must be {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bound_types</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
                            <span class="p">)</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper</span>
    <span class="k">return</span> <span class="n">decorate</span>
</pre></div>


<h3 id="24">2.4. 装饰器顺序</h3>
<p>一个函数还可以同时定义多个装饰器，比如：</p>
<div class="hlcode"><pre><span class="nd">@a</span>
<span class="nd">@b</span>
<span class="nd">@c</span>
<span class="k">def</span> <span class="nf">f</span> <span class="p">():</span>
    <span class="k">pass</span>
</pre></div>


<p>它的执行顺序是从里到外，最先调用最里层的装饰器，最后调用最外层的装饰器，它等效于</p>
<div class="hlcode"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">a</span><span class="p">(</span><span class="n">b</span><span class="p">(</span><span class="n">c</span><span class="p">(</span><span class="n">f</span><span class="p">)))</span>
</pre></div>


<h3 id="25">2.5. 装饰器类</h3>
<p>不仅装饰器可以装饰一个类，并且装饰器也可以是一个类！对于装饰器的唯一要求就是它的返回值必须可调用(callable)。这意味着装饰器必须实现 <strong>call</strong> 魔术方法，当你调用一个对象时，会隐式调用这个方法。函数当然是隐式设置这个方法的。我们重新将 identity_decorator 创建为一个类来看看它是如何工作的。</p>
<p>类装饰器<br />
接下来我们用面对对象的方法实现装饰器的功能，你应该有python面对对象编程的基础，这里面会用到魔法方法。</p>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Decrator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fn</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;初始化函数&quot;</span><span class="p">,</span><span class="n">fn</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_func</span> <span class="o">=</span> <span class="n">fn</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;打印的内容&quot;</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="nd">@Decrator</span>
<span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>

<span class="k">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="err">执行结果</span>

<span class="err">初始化函数</span> <span class="nb">sum</span>
<span class="err">打印的内容</span> <span class="mi">3</span> <span class="mi">3</span>
<span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">Decrator</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x0000024986FF7198</span><span class="o">&gt;</span>
</pre></div>


<p>解析：函数sum定义前加上@Decorator，相当于实例化类对象<code>Decorator(sum)</code>，同时初始化实例属性self._func=sum函数;接下来实例对象后加上()，会调用实例对象的__call__方法，打印出内容和参数，然后返回实例属性即sum函数并执行函数计算x+y。</p>
<h1 id="3">3. 好用的实例</h1>
<h2 id="31">3.1. 实现对异常进行捕获或重试</h2>
<div class="hlcode"><pre><span class="k">def</span> <span class="nf">exception_try</span><span class="p">(</span><span class="n">times</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">sleep_then_try_seconds</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">exception</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">while</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">times</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">exception</span> <span class="o">=</span> <span class="n">e</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s">&quot;Try {} times&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">sleep_then_try_seconds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">times</span><span class="p">:</span>
                        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">sleep_then_try_seconds</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">exception</span>
        <span class="k">return</span> <span class="n">wrapper</span>
    <span class="k">return</span> <span class="n">decorator</span>
</pre></div>


<p>基于上述修饰器可以减少<code>try...except</code> 导致大块代码缩进。</p>
<div class="hlcode"><pre><span class="nd">@exception_try</span><span class="p">(</span><span class="n">times</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">sleep_then_try_seconds</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">pymysql</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">host</span><span class="p">,</span> <span class="n">user</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">,</span> <span class="n">password</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">password</span><span class="p">,</span> <span class="n">db</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">db</span><span class="p">,</span> <span class="n">charset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">charset</span><span class="p">)</span>
</pre></div>


<p>这个装饰器方法用于实现异常重试，并且可以指定重试的时间间隔，实际使用下来效果较好。而且也不会因为 try...except 导致大块代码缩进。</p>
<h2 id="32">3.2. 确保数据库连接关闭</h2>
<p>（其它类似资源也可以这样实现）</p>
<div class="hlcode"><pre><span class="k">def</span> <span class="nf">with_db</span><span class="p">(</span><span class="n">db</span><span class="p">:</span> <span class="n">Connection</span><span class="p">,</span> <span class="n">exception_callback</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">db_context</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">exception_callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">exception_callback</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">db</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>
        <span class="k">return</span> <span class="n">db_context</span>

    <span class="k">return</span> <span class="n">decorator</span>

<span class="c"># 将 conf.db.connect() 对象作为 delete_task_from_job_queue 的第一个参数注入，task_id 这个参数以不定参数的方式传入 delete_task_from_job_queue</span>
</pre></div>


<div class="hlcode"><pre><span class="n">with_db</span><span class="p">(</span><span class="n">conf</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">connect</span><span class="p">())(</span><span class="n">delete_task_from_job_queue</span><span class="p">)(</span><span class="n">task_id</span><span class="p">)</span>
</pre></div>


<p>这个装饰器方法用于确保数据库连接在异常发生也能正常关闭，防止资源泄露。</p>
</div>
<div id="renote">
  <HR style=" FILTER: alpha (opacity = 100, finishopacity =0 , style= 3 )" width="80%" color=#987 cb 9 SIZE=3>
  <p>如果你觉得这篇文章对你有帮助，不妨请我喝杯咖啡，鼓励我创造更多!</p>
  <img src="/Wiki/static/images/pay.jpg" width="25%">
</div>

    </div>
    <div id="footer">
        <span>
            Copyright © 2020 zhang787jun.
            Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.
        </span>
    </div>

    
</body>
<script>
    function changeImgurl(site_root_url) {
        var images = document.images;
        var site_root = site_root_url;
        for (i = 0, len = images.length; i < len; i++) {
            image = images[i];
            image_src = image.src;
            if (image_src.search("attach") >= 0) {
                re_image_src = image_src.slice(image_src.search("attach"));
                abs_image_src = (site_root.endsWith("/")) ? site_root + re_image_src : site_root + "/" +
                    re_image_src;
                image.src = abs_image_src;
            }
        }
    }
    var site_root_url = "/Wiki";
    changeImgurl(site_root_url);
    let isMathjaxConfig = false; // 防止重复调用Config，造成性能损耗
    const initMathjaxConfig = () => {
        if (!window.MathJax) {
            return;
        }
        window.MathJax.Hub.Config({
            showProcessingMessages: false, //关闭js加载过程信息
            messageStyle: "none", //不显示信息
            jax: ["input/TeX", "output/HTML-CSS"],
            tex2jax: {
                inlineMath: [["$", "$"], ["\\(", "\\)"]], //行内公式选择符
                displayMath: [["$$", "$$"], ["\\[", "\\]"]], //段内公式选择符
                skipTags: ["script", "noscript", "style", "textarea", "pre", "code", "a"] //避开某些标签
            },
            "HTML-CSS": {
                availableFonts: ["STIX", "TeX"], //可选字体
                showMathMenu: false //关闭右击菜单显示
            }
        });
        isMathjaxConfig = true; //
    };
    if (isMathjaxConfig === false) {
        // 如果：没有配置MathJax
        initMathjaxConfig();
    };
</script>

</html>